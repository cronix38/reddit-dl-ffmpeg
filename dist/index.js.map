{"mappings":"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","sources":["<anon>","src/index.js","node_modules/@ffmpeg/ffmpeg/src/index.js","node_modules/regenerator-runtime/runtime.js","node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js","node_modules/@ffmpeg/ffmpeg/src/config.js","node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js","node_modules/@ffmpeg/ffmpeg/src/browser/index.js","node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js","node_modules/@ffmpeg/ffmpeg/package.json","node_modules/process/browser.js","node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js","node_modules/@ffmpeg/ffmpeg/src/utils/log.js","node_modules/@ffmpeg/ffmpeg/src/utils/errors.js","node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js","node_modules/m3u8-parser/dist/m3u8-parser.es.js","node_modules/@videojs/vhs-utils/es/stream.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js","node_modules/global/window.js","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var $15cc90f6d9fc0a3d$exports = {};\nvar $b6943471375d1c2a$exports = {};\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var $b6943471375d1c2a$var$runtime = function(exports) {\n    \"use strict\";\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var defineProperty = Object.defineProperty || function(obj, key, desc) {\n        obj[key] = desc.value;\n    };\n    var undefined; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n        return obj[key];\n    }\n    try {\n        // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n        define({}, \"\");\n    } catch (err) {\n        define = function(obj, key, value) {\n            return obj[key] = value;\n        };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []);\n        // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n        defineProperty(generator, \"_invoke\", {\n            value: makeInvokeMethod(innerFn, self, context)\n        });\n        return generator;\n    }\n    exports.wrap = wrap;\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n        try {\n            return {\n                type: \"normal\",\n                arg: fn.call(obj, arg)\n            };\n        } catch (err) {\n            return {\n                type: \"throw\",\n                arg: err\n            };\n        }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function() {\n        return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    defineProperty(Gp, \"constructor\", {\n        value: GeneratorFunctionPrototype,\n        configurable: true\n    });\n    defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n        value: GeneratorFunction,\n        configurable: true\n    });\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n        [\n            \"next\",\n            \"throw\",\n            \"return\"\n        ].forEach(function(method) {\n            define(prototype, method, function(arg) {\n                return this._invoke(method, arg);\n            });\n        });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n        if (Object.setPrototypeOf) Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n            define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n        }\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n    };\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function(arg) {\n        return {\n            __await: arg\n        };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n        function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n            if (record.type === \"throw\") reject(record.arg);\n            else {\n                var result = record.arg;\n                var value = result.value;\n                if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) return PromiseImpl.resolve(value.__await).then(function(value) {\n                    invoke(\"next\", value, resolve, reject);\n                }, function(err) {\n                    invoke(\"throw\", err, resolve, reject);\n                });\n                return PromiseImpl.resolve(value).then(function(unwrapped) {\n                    // When a yielded Promise is resolved, its final value becomes\n                    // the .value of the Promise<{value,done}> result for the\n                    // current iteration.\n                    result.value = unwrapped;\n                    resolve(result);\n                }, function(error) {\n                    // If a rejected Promise was yielded, throw the rejection back\n                    // into the async generator function so it can be handled there.\n                    return invoke(\"throw\", error, resolve, reject);\n                });\n            }\n        }\n        var previousPromise;\n        function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n                return new PromiseImpl(function(resolve, reject) {\n                    invoke(method, arg, resolve, reject);\n                });\n            }\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n        // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n        defineProperty(this, \"_invoke\", {\n            value: enqueue\n        });\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n        return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n        if (PromiseImpl === void 0) PromiseImpl = Promise;\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n         : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n        });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n            if (state === GenStateExecuting) throw new Error(\"Generator is already running\");\n            if (state === GenStateCompleted) {\n                if (method === \"throw\") throw arg;\n                // Be forgiving, per 25.3.3.3.3 of the spec:\n                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n                return doneResult();\n            }\n            context.method = method;\n            context.arg = arg;\n            while(true){\n                var delegate = context.delegate;\n                if (delegate) {\n                    var delegateResult = maybeInvokeDelegate(delegate, context);\n                    if (delegateResult) {\n                        if (delegateResult === ContinueSentinel) continue;\n                        return delegateResult;\n                    }\n                }\n                if (context.method === \"next\") // Setting context._sent for legacy support of Babel's\n                // function.sent implementation.\n                context.sent = context._sent = context.arg;\n                else if (context.method === \"throw\") {\n                    if (state === GenStateSuspendedStart) {\n                        state = GenStateCompleted;\n                        throw context.arg;\n                    }\n                    context.dispatchException(context.arg);\n                } else if (context.method === \"return\") context.abrupt(\"return\", context.arg);\n                state = GenStateExecuting;\n                var record = tryCatch(innerFn, self, context);\n                if (record.type === \"normal\") {\n                    // If an exception is thrown from innerFn, we leave state ===\n                    // GenStateExecuting and loop back for another invocation.\n                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                    if (record.arg === ContinueSentinel) continue;\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                } else if (record.type === \"throw\") {\n                    state = GenStateCompleted;\n                    // Dispatch the exception by looping back around to the\n                    // context.dispatchException(context.arg) call above.\n                    context.method = \"throw\";\n                    context.arg = record.arg;\n                }\n            }\n        };\n    }\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n        var methodName = context.method;\n        var method = delegate.iterator[methodName];\n        if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method, or a missing .next mehtod, always terminate the\n            // yield* loop.\n            context.delegate = null;\n            // Note: [\"return\"] must be used for ES3 parsing compatibility.\n            if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n                // If the delegate iterator has a return method, give it a\n                // chance to clean up.\n                context.method = \"return\";\n                context.arg = undefined;\n                maybeInvokeDelegate(delegate, context);\n                if (context.method === \"throw\") // If maybeInvokeDelegate(context) changed context.method from\n                // \"return\" to \"throw\", let that override the TypeError below.\n                return ContinueSentinel;\n            }\n            if (methodName !== \"return\") {\n                context.method = \"throw\";\n                context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n            }\n            return ContinueSentinel;\n        }\n        var record = tryCatch(method, delegate.iterator, context.arg);\n        if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        var info = record.arg;\n        if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value;\n            // Resume execution at the desired location (see delegateYield).\n            context.next = delegate.nextLoc;\n            // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n            if (context.method !== \"return\") {\n                context.method = \"next\";\n                context.arg = undefined;\n            }\n        } else // Re-yield the result returned by the delegate method.\n        return info;\n        // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n        context.delegate = null;\n        return ContinueSentinel;\n    }\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function() {\n        return this;\n    });\n    define(Gp, \"toString\", function() {\n        return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n        var entry = {\n            tryLoc: locs[0]\n        };\n        if (1 in locs) entry.catchLoc = locs[1];\n        if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n        }\n        this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n    }\n    function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [\n            {\n                tryLoc: \"root\"\n            }\n        ];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n    }\n    exports.keys = function(val) {\n        var object = Object(val);\n        var keys = [];\n        for(var key in object)keys.push(key);\n        keys.reverse();\n        // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n        return function next() {\n            while(keys.length){\n                var key = keys.pop();\n                if (key in object) {\n                    next.value = key;\n                    next.done = false;\n                    return next;\n                }\n            }\n            // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n            next.done = true;\n            return next;\n        };\n    };\n    function values(iterable) {\n        if (iterable) {\n            var iteratorMethod = iterable[iteratorSymbol];\n            if (iteratorMethod) return iteratorMethod.call(iterable);\n            if (typeof iterable.next === \"function\") return iterable;\n            if (!isNaN(iterable.length)) {\n                var i = -1, next = function next() {\n                    while(++i < iterable.length)if (hasOwn.call(iterable, i)) {\n                        next.value = iterable[i];\n                        next.done = false;\n                        return next;\n                    }\n                    next.value = undefined;\n                    next.done = true;\n                    return next;\n                };\n                return next.next = next;\n            }\n        }\n        // Return an iterator with no values.\n        return {\n            next: doneResult\n        };\n    }\n    exports.values = values;\n    function doneResult() {\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    Context.prototype = {\n        constructor: Context,\n        reset: function(skipTempReset) {\n            this.prev = 0;\n            this.next = 0;\n            // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n            if (!skipTempReset) {\n                for(var name in this)// Not sure about the optimal order of these conditions:\n                if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) this[name] = undefined;\n            }\n        },\n        stop: function() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n            if (rootRecord.type === \"throw\") throw rootRecord.arg;\n            return this.rval;\n        },\n        dispatchException: function(exception) {\n            if (this.done) throw exception;\n            var context = this;\n            function handle(loc, caught) {\n                record.type = \"throw\";\n                record.arg = exception;\n                context.next = loc;\n                if (caught) {\n                    // If the dispatched exception was caught by a catch block,\n                    // then let that catch block handle the exception normally.\n                    context.method = \"next\";\n                    context.arg = undefined;\n                }\n                return !!caught;\n            }\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                var record = entry.completion;\n                if (entry.tryLoc === \"root\") // Exception thrown outside of any try block that could handle\n                // it, so set the completion value of the entire function to\n                // throw the exception.\n                return handle(\"end\");\n                if (entry.tryLoc <= this.prev) {\n                    var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                    var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                    if (hasCatch && hasFinally) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                        else if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else if (hasCatch) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                    } else if (hasFinally) {\n                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else throw new Error(\"try statement without catch or finally\");\n                }\n            }\n        },\n        abrupt: function(type, arg) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                    var finallyEntry = entry;\n                    break;\n                }\n            }\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) // Ignore the finally entry if control is not jumping to a\n            // location outside the try/catch block.\n            finallyEntry = null;\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n            if (finallyEntry) {\n                this.method = \"next\";\n                this.next = finallyEntry.finallyLoc;\n                return ContinueSentinel;\n            }\n            return this.complete(record);\n        },\n        complete: function(record, afterLoc) {\n            if (record.type === \"throw\") throw record.arg;\n            if (record.type === \"break\" || record.type === \"continue\") this.next = record.arg;\n            else if (record.type === \"return\") {\n                this.rval = this.arg = record.arg;\n                this.method = \"return\";\n                this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) this.next = afterLoc;\n            return ContinueSentinel;\n        },\n        finish: function(finallyLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.finallyLoc === finallyLoc) {\n                    this.complete(entry.completion, entry.afterLoc);\n                    resetTryEntry(entry);\n                    return ContinueSentinel;\n                }\n            }\n        },\n        \"catch\": function(tryLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc === tryLoc) {\n                    var record = entry.completion;\n                    if (record.type === \"throw\") {\n                        var thrown = record.arg;\n                        resetTryEntry(entry);\n                    }\n                    return thrown;\n                }\n            }\n            // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n            throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function(iterable, resultName, nextLoc) {\n            this.delegate = {\n                iterator: values(iterable),\n                resultName: resultName,\n                nextLoc: nextLoc\n            };\n            if (this.method === \"next\") // Deliberately forget the last sent value so that we don't\n            // accidentally pass it on to the delegate.\n            this.arg = undefined;\n            return ContinueSentinel;\n        }\n    };\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n}(// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n(0, $b6943471375d1c2a$exports));\ntry {\n    regeneratorRuntime = $b6943471375d1c2a$var$runtime;\n} catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") globalThis.regeneratorRuntime = $b6943471375d1c2a$var$runtime;\n    else Function(\"r\", \"regeneratorRuntime = r\")($b6943471375d1c2a$var$runtime);\n}\n\n\nvar $3b3cc656e4f26aad$exports = {};\nvar $616f69560e488f29$exports = {};\n$616f69560e488f29$exports = {\n    defaultArgs: [\n        /* args[0] is always the binary path */ \"./ffmpeg\",\n        /* Disable interaction mode */ \"-nostdin\",\n        /* Force to override output file */ \"-y\"\n    ],\n    baseOptions: {\n        /* Flag to turn on/off log messages in console */ log: false,\n        /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */ logger: ()=>{},\n        /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */ progress: ()=>{},\n        /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */ corePath: \"\"\n    }\n};\n\n\nvar $3b3cc656e4f26aad$require$defaultArgs = $616f69560e488f29$exports.defaultArgs;\nvar $3b3cc656e4f26aad$require$baseOptions = $616f69560e488f29$exports.baseOptions;\nvar $8e4d7ec1a6533651$exports = {};\n$8e4d7ec1a6533651$exports = (Core, args)=>{\n    const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n    args.forEach((s, idx)=>{\n        const sz = Core.lengthBytesUTF8(s) + 1;\n        const buf = Core._malloc(sz);\n        Core.stringToUTF8(s, buf, sz);\n        Core.setValue(argsPtr + Uint32Array.BYTES_PER_ELEMENT * idx, buf, \"i32\");\n    });\n    return [\n        args.length,\n        argsPtr\n    ];\n};\n\n\nvar $a5bcf3ae1eb45eef$exports = {};\n$a5bcf3ae1eb45eef$exports = JSON.parse('{\"name\":\"@ffmpeg/ffmpeg\",\"version\":\"0.11.6\",\"description\":\"FFmpeg WebAssembly version\",\"main\":\"src/index.js\",\"types\":\"src/index.d.ts\",\"directories\":{\"example\":\"examples\"},\"scripts\":{\"start\":\"node scripts/server.js\",\"start:worker\":\"node scripts/worker-server.js\",\"build\":\"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\"build:worker\":\"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\"prepublishOnly\":\"npm run build\",\"lint\":\"eslint src\",\"wait\":\"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\"test\":\"npm-run-all -p -r start test:all\",\"test:all\":\"npm-run-all wait test:browser:ffmpeg test:node:all\",\"test:node\":\"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\"test:node:all\":\"npm run test:node -- ./tests/*.test.js\",\"test:browser\":\"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\"test:browser:ffmpeg\":\"npm run test:browser -- -f ./tests/ffmpeg.test.html\"},\"browser\":{\"./src/node/index.js\":\"./src/browser/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"},\"keywords\":[\"ffmpeg\",\"WebAssembly\",\"video\"],\"author\":\"Jerome Wu <jeromewus@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"},\"engines\":{\"node\":\">=12.16.1\"},\"homepage\":\"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\"dependencies\":{\"is-url\":\"^1.2.4\",\"node-fetch\":\"^2.6.1\",\"regenerator-runtime\":\"^0.13.7\",\"resolve-url\":\"^0.2.1\"},\"devDependencies\":{\"@babel/core\":\"^7.12.3\",\"@babel/preset-env\":\"^7.12.1\",\"@ffmpeg/core\":\"^0.11.0\",\"@types/emscripten\":\"^1.39.4\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.1.0\",\"chai\":\"^4.2.0\",\"cors\":\"^2.8.5\",\"eslint\":\"^7.12.1\",\"eslint-config-airbnb-base\":\"^14.1.0\",\"eslint-plugin-import\":\"^2.22.1\",\"express\":\"^4.17.1\",\"mocha\":\"^8.2.1\",\"mocha-headless-chrome\":\"^2.0.3\",\"npm-run-all\":\"^4.1.5\",\"wait-on\":\"^5.3.0\",\"webpack\":\"^5.3.2\",\"webpack-cli\":\"^4.1.0\",\"webpack-dev-middleware\":\"^4.0.0\"}}');\n\n\nvar $d3c1734dacb01657$exports = {};\n// shim for using process in browser\nvar $d3c1734dacb01657$var$process = $d3c1734dacb01657$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d3c1734dacb01657$var$cachedSetTimeout;\nvar $d3c1734dacb01657$var$cachedClearTimeout;\nfunction $d3c1734dacb01657$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $d3c1734dacb01657$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        else $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        else $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    }\n})();\nfunction $d3c1734dacb01657$var$runTimeout(fun) {\n    if ($d3c1734dacb01657$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedSetTimeout === $d3c1734dacb01657$var$defaultSetTimout || !$d3c1734dacb01657$var$cachedSetTimeout) && setTimeout) {\n        $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d3c1734dacb01657$var$runClearTimeout(marker) {\n    if ($d3c1734dacb01657$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedClearTimeout === $d3c1734dacb01657$var$defaultClearTimeout || !$d3c1734dacb01657$var$cachedClearTimeout) && clearTimeout) {\n        $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d3c1734dacb01657$var$queue = [];\nvar $d3c1734dacb01657$var$draining = false;\nvar $d3c1734dacb01657$var$currentQueue;\nvar $d3c1734dacb01657$var$queueIndex = -1;\nfunction $d3c1734dacb01657$var$cleanUpNextTick() {\n    if (!$d3c1734dacb01657$var$draining || !$d3c1734dacb01657$var$currentQueue) return;\n    $d3c1734dacb01657$var$draining = false;\n    if ($d3c1734dacb01657$var$currentQueue.length) $d3c1734dacb01657$var$queue = $d3c1734dacb01657$var$currentQueue.concat($d3c1734dacb01657$var$queue);\n    else $d3c1734dacb01657$var$queueIndex = -1;\n    if ($d3c1734dacb01657$var$queue.length) $d3c1734dacb01657$var$drainQueue();\n}\nfunction $d3c1734dacb01657$var$drainQueue() {\n    if ($d3c1734dacb01657$var$draining) return;\n    var timeout = $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$cleanUpNextTick);\n    $d3c1734dacb01657$var$draining = true;\n    var len = $d3c1734dacb01657$var$queue.length;\n    while(len){\n        $d3c1734dacb01657$var$currentQueue = $d3c1734dacb01657$var$queue;\n        $d3c1734dacb01657$var$queue = [];\n        while(++$d3c1734dacb01657$var$queueIndex < len)if ($d3c1734dacb01657$var$currentQueue) $d3c1734dacb01657$var$currentQueue[$d3c1734dacb01657$var$queueIndex].run();\n        $d3c1734dacb01657$var$queueIndex = -1;\n        len = $d3c1734dacb01657$var$queue.length;\n    }\n    $d3c1734dacb01657$var$currentQueue = null;\n    $d3c1734dacb01657$var$draining = false;\n    $d3c1734dacb01657$var$runClearTimeout(timeout);\n}\n$d3c1734dacb01657$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d3c1734dacb01657$var$queue.push(new $d3c1734dacb01657$var$Item(fun, args));\n    if ($d3c1734dacb01657$var$queue.length === 1 && !$d3c1734dacb01657$var$draining) $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d3c1734dacb01657$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d3c1734dacb01657$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d3c1734dacb01657$var$process.title = \"browser\";\n$d3c1734dacb01657$var$process.browser = true;\n$d3c1734dacb01657$var$process.env = {};\n$d3c1734dacb01657$var$process.argv = [];\n$d3c1734dacb01657$var$process.version = \"\"; // empty string to avoid regexp issues\n$d3c1734dacb01657$var$process.versions = {};\nfunction $d3c1734dacb01657$var$noop() {}\n$d3c1734dacb01657$var$process.on = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.addListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.once = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.off = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeAllListeners = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.emit = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependOnceListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.listeners = function(name) {\n    return [];\n};\n$d3c1734dacb01657$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$d3c1734dacb01657$var$process.cwd = function() {\n    return \"/\";\n};\n$d3c1734dacb01657$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$d3c1734dacb01657$var$process.umask = function() {\n    return 0;\n};\n\n\n/*\n * Default options for browser environment\n */ const $d67d306687d6b921$var$corePath = (typeof $d3c1734dacb01657$exports, `https://unpkg.com/@ffmpeg/core@${(0, (/*@__PURE__*/$parcel$interopDefault($a5bcf3ae1eb45eef$exports))).devDependencies[\"@ffmpeg/core\"].substring(1)}/dist/ffmpeg-core.js`);\nvar $d67d306687d6b921$export$2e2bcd8739ae039 = {\n    corePath: $d67d306687d6b921$var$corePath\n};\n\n\n/* eslint-disable no-undef */ var $051b5e070f34ce4a$exports = {};\nlet $051b5e070f34ce4a$var$logging = false;\nlet $051b5e070f34ce4a$var$customLogger = ()=>{};\nconst $051b5e070f34ce4a$var$setLogging = (_logging)=>{\n    $051b5e070f34ce4a$var$logging = _logging;\n};\nconst $051b5e070f34ce4a$var$setCustomLogger = (logger)=>{\n    $051b5e070f34ce4a$var$customLogger = logger;\n};\nconst $051b5e070f34ce4a$var$log = (type, message)=>{\n    $051b5e070f34ce4a$var$customLogger({\n        type: type,\n        message: message\n    });\n    if ($051b5e070f34ce4a$var$logging) console.log(`[${type}] ${message}`);\n};\n$051b5e070f34ce4a$exports = {\n    logging: $051b5e070f34ce4a$var$logging,\n    setLogging: $051b5e070f34ce4a$var$setLogging,\n    setCustomLogger: $051b5e070f34ce4a$var$setCustomLogger,\n    log: $051b5e070f34ce4a$var$log\n};\n\n\nvar $43717573ac1f31b3$exports = {};\nconst $43717573ac1f31b3$var$CREATE_FFMPEG_CORE_IS_NOT_DEFINED = (corePath)=>`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`;\n$43717573ac1f31b3$exports = {\n    CREATE_FFMPEG_CORE_IS_NOT_DEFINED: $43717573ac1f31b3$var$CREATE_FFMPEG_CORE_IS_NOT_DEFINED\n};\n\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */ const $88271dc11418d3fa$var$toBlobURL = async (url, mimeType)=>{\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `fetch ${url}`);\n    const buf = await (await fetch(url)).arrayBuffer();\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `${url} file size = ${buf.byteLength} bytes`);\n    const blob = new Blob([\n        buf\n    ], {\n        type: mimeType\n    });\n    const blobURL = URL.createObjectURL(blob);\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `${url} blob URL = ${blobURL}`);\n    return blobURL;\n};\nconst $88271dc11418d3fa$export$e2417051082334b7 = async ({ corePath: _corePath, workerPath: _workerPath, wasmPath: _wasmPath })=>{\n    // in Web Worker context\n    // eslint-disable-next-line\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (typeof _corePath !== \"string\") throw Error(\"corePath should be a string!\");\n        const coreRemotePath = new URL(_corePath, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js\").href;\n        const corePath = await $88271dc11418d3fa$var$toBlobURL(coreRemotePath, \"application/javascript\");\n        const wasmPath = await $88271dc11418d3fa$var$toBlobURL(_wasmPath !== undefined ? _wasmPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"), \"application/wasm\");\n        const workerPath = await $88271dc11418d3fa$var$toBlobURL(_workerPath !== undefined ? _workerPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"), \"application/javascript\");\n        if (typeof createFFmpegCore === \"undefined\") return new Promise((resolve)=>{\n            globalThis.importScripts(corePath);\n            if (typeof createFFmpegCore === \"undefined\") throw Error((0, $43717573ac1f31b3$exports.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath));\n            (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script loaded\");\n            resolve({\n                createFFmpegCore: createFFmpegCore,\n                corePath: corePath,\n                wasmPath: wasmPath,\n                workerPath: workerPath\n            });\n        });\n        (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script is loaded already\");\n        return Promise.resolve({\n            createFFmpegCore: createFFmpegCore,\n            corePath: corePath,\n            wasmPath: wasmPath,\n            workerPath: workerPath\n        });\n    }\n    if (typeof _corePath !== \"string\") throw Error(\"corePath should be a string!\");\n    const coreRemotePath = new URL(_corePath, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js\").href;\n    const corePath = await $88271dc11418d3fa$var$toBlobURL(coreRemotePath, \"application/javascript\");\n    const wasmPath = await $88271dc11418d3fa$var$toBlobURL(_wasmPath !== undefined ? _wasmPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"), \"application/wasm\");\n    const workerPath = await $88271dc11418d3fa$var$toBlobURL(_workerPath !== undefined ? _workerPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"), \"application/javascript\");\n    if (typeof createFFmpegCore === \"undefined\") return new Promise((resolve)=>{\n        const script = document.createElement(\"script\");\n        const eventHandler = ()=>{\n            script.removeEventListener(\"load\", eventHandler);\n            if (typeof createFFmpegCore === \"undefined\") throw Error((0, $43717573ac1f31b3$exports.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath));\n            (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script loaded\");\n            resolve({\n                createFFmpegCore: createFFmpegCore,\n                corePath: corePath,\n                wasmPath: wasmPath,\n                workerPath: workerPath\n            });\n        };\n        script.src = corePath;\n        script.type = \"text/javascript\";\n        script.addEventListener(\"load\", eventHandler);\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script is loaded already\");\n    return Promise.resolve({\n        createFFmpegCore: createFFmpegCore,\n        corePath: corePath,\n        wasmPath: wasmPath,\n        workerPath: workerPath\n    });\n};\n\n\nconst $4e2a226da6deaa1a$var$readFromBlobOrFile = (blob)=>new Promise((resolve, reject)=>{\n        const fileReader = new FileReader();\n        fileReader.onload = ()=>{\n            resolve(fileReader.result);\n        };\n        fileReader.onerror = ({ target: { error: { code: code } } })=>{\n            reject(Error(`File could not be read! Code=${code}`));\n        };\n        fileReader.readAsArrayBuffer(blob);\n    });\nconst $4e2a226da6deaa1a$export$d965bcb23f9d06c5 = async (_data)=>{\n    let data = _data;\n    if (typeof _data === \"undefined\") return new Uint8Array();\n    if (typeof _data === \"string\") {\n        /* From base64 format */ if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) data = atob(_data.split(\",\")[1]).split(\"\").map((c)=>c.charCodeAt(0));\n        else {\n            const res = await fetch(new URL(_data, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js\").href);\n            data = await res.arrayBuffer();\n        }\n    } else if (_data instanceof File || _data instanceof Blob) data = await $4e2a226da6deaa1a$var$readFromBlobOrFile(_data);\n    return new Uint8Array(data);\n};\n\n\n\n\nvar $3b3cc656e4f26aad$require$defaultOptions = $d67d306687d6b921$export$2e2bcd8739ae039;\nvar $3b3cc656e4f26aad$require$getCreateFFmpegCore = $88271dc11418d3fa$export$e2417051082334b7;\n\nvar $3b3cc656e4f26aad$require$version = $a5bcf3ae1eb45eef$exports.version;\nconst $3b3cc656e4f26aad$var$NO_LOAD = Error(\"ffmpeg.wasm is not ready, make sure you have completed load().\");\n$3b3cc656e4f26aad$exports = (_options = {})=>{\n    const { log: optLog, logger: logger, progress: optProgress, ...options } = {\n        ...$3b3cc656e4f26aad$require$baseOptions,\n        ...$3b3cc656e4f26aad$require$defaultOptions,\n        ..._options\n    };\n    let Core = null;\n    let ffmpeg = null;\n    let runResolve = null;\n    let runReject = null;\n    let running = false;\n    let customLogger = ()=>{};\n    let logging = optLog;\n    let progress = optProgress;\n    let duration = 0;\n    let frames = 0;\n    let readFrames = false;\n    let ratio = 0;\n    const detectCompletion = (message)=>{\n        if (message === \"FFMPEG_END\" && runResolve !== null) {\n            runResolve();\n            runResolve = null;\n            runReject = null;\n            running = false;\n        }\n    };\n    const log = (type, message)=>{\n        customLogger({\n            type: type,\n            message: message\n        });\n        if (logging) console.log(`[${type}] ${message}`);\n    };\n    const ts2sec = (ts)=>{\n        const [h, m, s] = ts.split(\":\");\n        return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);\n    };\n    const parseProgress = (message, prog)=>{\n        if (typeof message === \"string\") {\n            if (message.startsWith(\"  Duration\")) {\n                const ts = message.split(\", \")[0].split(\": \")[1];\n                const d = ts2sec(ts);\n                prog({\n                    duration: d,\n                    ratio: ratio\n                });\n                if (duration === 0 || duration > d) {\n                    duration = d;\n                    readFrames = true;\n                }\n            } else if (readFrames && message.startsWith(\"    Stream\")) {\n                const match = message.match(/([\\d.]+) fps/);\n                if (match) {\n                    const fps = parseFloat(match[1]);\n                    frames = duration * fps;\n                } else frames = 0;\n                readFrames = false;\n            } else if (message.startsWith(\"frame\") || message.startsWith(\"size\")) {\n                const ts = message.split(\"time=\")[1].split(\" \")[0];\n                const t = ts2sec(ts);\n                const match = message.match(/frame=\\s*(\\d+)/);\n                if (frames && match) {\n                    const f = parseFloat(match[1]);\n                    ratio = Math.min(f / frames, 1);\n                } else ratio = t / duration;\n                prog({\n                    ratio: ratio,\n                    time: t\n                });\n            } else if (message.startsWith(\"video:\")) {\n                prog({\n                    ratio: 1\n                });\n                duration = 0;\n            }\n        }\n    };\n    const parseMessage = ({ type: type, message: message })=>{\n        log(type, message);\n        parseProgress(message, progress);\n        detectCompletion(message);\n    };\n    /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */ const load = async ()=>{\n        log(\"info\", \"load ffmpeg-core\");\n        if (Core === null) {\n            log(\"info\", \"loading ffmpeg-core\");\n            /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */ const { createFFmpegCore: createFFmpegCore, corePath: corePath, workerPath: workerPath, wasmPath: wasmPath } = await $3b3cc656e4f26aad$require$getCreateFFmpegCore(options);\n            Core = await createFFmpegCore({\n                /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */ mainScriptUrlOrBlob: corePath,\n                printErr: (message)=>parseMessage({\n                        type: \"fferr\",\n                        message: message\n                    }),\n                print: (message)=>parseMessage({\n                        type: \"ffout\",\n                        message: message\n                    }),\n                /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */ locateFile: (path, prefix)=>{\n                    if (typeof window !== \"undefined\" || typeof WorkerGlobalScope !== \"undefined\") {\n                        if (typeof wasmPath !== \"undefined\" && path.endsWith(\"ffmpeg-core.wasm\")) return wasmPath;\n                        if (typeof workerPath !== \"undefined\" && path.endsWith(\"ffmpeg-core.worker.js\")) return workerPath;\n                    }\n                    return prefix + path;\n                }\n            });\n            ffmpeg = Core.cwrap(options.mainName || \"proxy_main\", \"number\", [\n                \"number\",\n                \"number\"\n            ]);\n            log(\"info\", \"ffmpeg-core loaded\");\n        } else throw Error(\"ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.\");\n    };\n    /*\n   * Determine whether the Core is loaded.\n   */ const isLoaded = ()=>Core !== null;\n    /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */ const run = (..._args)=>{\n        log(\"info\", `run ffmpeg command: ${_args.join(\" \")}`);\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else if (running) throw Error(\"ffmpeg.wasm can only run one command at a time\");\n        else {\n            running = true;\n            return new Promise((resolve, reject)=>{\n                const args = [\n                    ...$3b3cc656e4f26aad$require$defaultArgs,\n                    ..._args\n                ].filter((s)=>s.length !== 0);\n                runResolve = resolve;\n                runReject = reject;\n                ffmpeg(...$8e4d7ec1a6533651$exports(Core, args));\n            });\n        }\n    };\n    /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */ const FS = (method, ...args)=>{\n        log(\"info\", `run FS.${method} ${args.map((arg)=>typeof arg === \"string\" ? arg : `<${arg.length} bytes binary file>`).join(\" \")}`);\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else {\n            let ret = null;\n            try {\n                ret = Core.FS[method](...args);\n            } catch (e) {\n                if (method === \"readdir\") throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n                else if (method === \"readFile\") throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n                else throw Error(\"Oops, something went wrong in FS operation.\");\n            }\n            return ret;\n        }\n    };\n    /**\n   * forcibly terminate the ffmpeg program.\n   */ const exit = ()=>{\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else {\n            // if there's any pending runs, reject them\n            if (runReject) runReject(\"ffmpeg has exited\");\n            running = false;\n            try {\n                Core.exit(1);\n            } catch (err) {\n                log(err.message);\n                if (runReject) runReject(err);\n            } finally{\n                Core = null;\n                ffmpeg = null;\n                runResolve = null;\n                runReject = null;\n            }\n        }\n    };\n    const setProgress = (_progress)=>{\n        progress = _progress;\n    };\n    const setLogger = (_logger)=>{\n        customLogger = _logger;\n    };\n    const setLogging = (_logging)=>{\n        logging = _logging;\n    };\n    log(\"info\", `use ffmpeg.wasm v${$3b3cc656e4f26aad$require$version}`);\n    return {\n        setProgress: setProgress,\n        setLogger: setLogger,\n        setLogging: setLogging,\n        load: load,\n        isLoaded: isLoaded,\n        run: run,\n        exit: exit,\n        FS: FS\n    };\n};\n\n\n\nvar $15cc90f6d9fc0a3d$require$fetchFile = $4e2a226da6deaa1a$export$d965bcb23f9d06c5;\n$15cc90f6d9fc0a3d$exports = {\n    createFFmpeg: /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */ $3b3cc656e4f26aad$exports,\n    fetchFile: $15cc90f6d9fc0a3d$require$fetchFile\n};\n\n\n/*! @name m3u8-parser @version 7.1.0 @license Apache-2.0 */ /**\n * @file stream.js\n */ /**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */ var $240ec63f2cada8d3$export$2e2bcd8739ae039 = /*#__PURE__*/ function() {\n    function Stream() {\n        this.listeners = {};\n    }\n    /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */ var _proto = Stream.prototype;\n    _proto.on = function on(type, listener) {\n        if (!this.listeners[type]) this.listeners[type] = [];\n        this.listeners[type].push(listener);\n    } /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */ ;\n    _proto.off = function off(type, listener) {\n        if (!this.listeners[type]) return false;\n        var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n        // In Video.js we slice listener functions\n        // on trigger so that it does not mess up the order\n        // while we loop through.\n        //\n        // Here we slice on off so that the loop in trigger\n        // can continue using it's old reference to loop without\n        // messing up the order.\n        this.listeners[type] = this.listeners[type].slice(0);\n        this.listeners[type].splice(index, 1);\n        return index > -1;\n    } /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */ ;\n    _proto.trigger = function trigger(type) {\n        var callbacks = this.listeners[type];\n        if (!callbacks) return;\n         // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n        if (arguments.length === 2) {\n            var length = callbacks.length;\n            for(var i = 0; i < length; ++i)callbacks[i].call(this, arguments[1]);\n        } else {\n            var args = Array.prototype.slice.call(arguments, 1);\n            var _length = callbacks.length;\n            for(var _i = 0; _i < _length; ++_i)callbacks[_i].apply(this, args);\n        }\n    } /**\n   * Destroys the stream and cleans up.\n   */ ;\n    _proto.dispose = function dispose() {\n        this.listeners = {};\n    } /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */ ;\n    _proto.pipe = function pipe(destination) {\n        this.on(\"data\", function(data) {\n            destination.push(data);\n        });\n    };\n    return Stream;\n}();\n\n\nvar $fbb6a7bc8836e7ee$exports = {};\nfunction $fbb6a7bc8836e7ee$var$_extends() {\n    return $fbb6a7bc8836e7ee$exports = $fbb6a7bc8836e7ee$var$_extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, $fbb6a7bc8836e7ee$exports.__esModule = true, $fbb6a7bc8836e7ee$exports[\"default\"] = $fbb6a7bc8836e7ee$exports, $fbb6a7bc8836e7ee$var$_extends.apply(null, arguments);\n}\n$fbb6a7bc8836e7ee$exports = $fbb6a7bc8836e7ee$var$_extends, $fbb6a7bc8836e7ee$exports.__esModule = true, $fbb6a7bc8836e7ee$exports[\"default\"] = $fbb6a7bc8836e7ee$exports;\n\n\nvar $d154510a897fbed3$exports = {};\nvar $d154510a897fbed3$var$win;\nif (typeof window !== \"undefined\") $d154510a897fbed3$var$win = window;\nelse if (typeof $parcel$global !== \"undefined\") $d154510a897fbed3$var$win = $parcel$global;\nelse if (typeof self !== \"undefined\") $d154510a897fbed3$var$win = self;\nelse $d154510a897fbed3$var$win = {};\n$d154510a897fbed3$exports = $d154510a897fbed3$var$win;\n\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $0934e0939605d48c$export$a143d493d941bafc;\nvar $0934e0939605d48c$export$e4cf37d7f6fb9e0a;\nvar $0934e0939605d48c$export$f99ded8fe4b79145;\nvar $0934e0939605d48c$export$599f31c3813fae4d;\n\"use strict\";\nvar $8a0a73e6b73fd0c4$export$a48f0734ac7c2329;\nvar $8a0a73e6b73fd0c4$export$d622b2ad8d90c771;\nvar $8a0a73e6b73fd0c4$export$6100ba28696e12de;\n\"use strict\";\n$8a0a73e6b73fd0c4$export$a48f0734ac7c2329 = $8a0a73e6b73fd0c4$var$byteLength;\n$8a0a73e6b73fd0c4$export$d622b2ad8d90c771 = $8a0a73e6b73fd0c4$var$toByteArray;\n$8a0a73e6b73fd0c4$export$6100ba28696e12de = $8a0a73e6b73fd0c4$var$fromByteArray;\nvar $8a0a73e6b73fd0c4$var$lookup = [];\nvar $8a0a73e6b73fd0c4$var$revLookup = [];\nvar $8a0a73e6b73fd0c4$var$Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar $8a0a73e6b73fd0c4$var$code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor(var $8a0a73e6b73fd0c4$var$i = 0, $8a0a73e6b73fd0c4$var$len = $8a0a73e6b73fd0c4$var$code.length; $8a0a73e6b73fd0c4$var$i < $8a0a73e6b73fd0c4$var$len; ++$8a0a73e6b73fd0c4$var$i){\n    $8a0a73e6b73fd0c4$var$lookup[$8a0a73e6b73fd0c4$var$i] = $8a0a73e6b73fd0c4$var$code[$8a0a73e6b73fd0c4$var$i];\n    $8a0a73e6b73fd0c4$var$revLookup[$8a0a73e6b73fd0c4$var$code.charCodeAt($8a0a73e6b73fd0c4$var$i)] = $8a0a73e6b73fd0c4$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$8a0a73e6b73fd0c4$var$revLookup[\"-\".charCodeAt(0)] = 62;\n$8a0a73e6b73fd0c4$var$revLookup[\"_\".charCodeAt(0)] = 63;\nfunction $8a0a73e6b73fd0c4$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $8a0a73e6b73fd0c4$var$byteLength(b64) {\n    var lens = $8a0a73e6b73fd0c4$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $8a0a73e6b73fd0c4$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $8a0a73e6b73fd0c4$var$toByteArray(b64) {\n    var tmp;\n    var lens = $8a0a73e6b73fd0c4$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $8a0a73e6b73fd0c4$var$Arr($8a0a73e6b73fd0c4$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 18 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 2 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i)] << 10 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $8a0a73e6b73fd0c4$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $8a0a73e6b73fd0c4$var$tripletToBase64(num) {\n    return $8a0a73e6b73fd0c4$var$lookup[num >> 18 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num >> 12 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num >> 6 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[num & 0x3F];\n}\nfunction $8a0a73e6b73fd0c4$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($8a0a73e6b73fd0c4$var$tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction $8a0a73e6b73fd0c4$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($8a0a73e6b73fd0c4$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($8a0a73e6b73fd0c4$var$lookup[tmp >> 2] + $8a0a73e6b73fd0c4$var$lookup[tmp << 4 & 0x3F] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($8a0a73e6b73fd0c4$var$lookup[tmp >> 10] + $8a0a73e6b73fd0c4$var$lookup[tmp >> 4 & 0x3F] + $8a0a73e6b73fd0c4$var$lookup[tmp << 2 & 0x3F] + \"=\");\n    }\n    return parts.join(\"\");\n}\n\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $998eb38f4d082829$export$aafa59e2e03f2942;\nvar $998eb38f4d082829$export$68d8715fc104d294;\n$998eb38f4d082829$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$998eb38f4d082829$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n\nconst $0934e0939605d48c$var$customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" // eslint-disable-line dot-notation\n ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") // eslint-disable-line dot-notation\n : null;\n$0934e0939605d48c$export$a143d493d941bafc = $0934e0939605d48c$var$Buffer;\n$0934e0939605d48c$export$e4cf37d7f6fb9e0a = $0934e0939605d48c$var$SlowBuffer;\n$0934e0939605d48c$export$f99ded8fe4b79145 = 50;\nconst $0934e0939605d48c$var$K_MAX_LENGTH = 0x7fffffff;\n$0934e0939605d48c$export$599f31c3813fae4d = $0934e0939605d48c$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $0934e0939605d48c$var$Buffer.TYPED_ARRAY_SUPPORT = $0934e0939605d48c$var$typedArraySupport();\nif (!$0934e0939605d48c$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $0934e0939605d48c$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($0934e0939605d48c$var$Buffer.prototype, \"parent\", {\n    enumerable: true,\n    get: function() {\n        if (!$0934e0939605d48c$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($0934e0939605d48c$var$Buffer.prototype, \"offset\", {\n    enumerable: true,\n    get: function() {\n        if (!$0934e0939605d48c$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $0934e0939605d48c$var$createBuffer(length) {\n    if (length > $0934e0939605d48c$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $0934e0939605d48c$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $0934e0939605d48c$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $0934e0939605d48c$var$allocUnsafe(arg);\n    }\n    return $0934e0939605d48c$var$from(arg, encodingOrOffset, length);\n}\n$0934e0939605d48c$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $0934e0939605d48c$var$from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") return $0934e0939605d48c$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $0934e0939605d48c$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($0934e0939605d48c$var$isInstance(value, ArrayBuffer) || value && $0934e0939605d48c$var$isInstance(value.buffer, ArrayBuffer)) return $0934e0939605d48c$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== \"undefined\" && ($0934e0939605d48c$var$isInstance(value, SharedArrayBuffer) || value && $0934e0939605d48c$var$isInstance(value.buffer, SharedArrayBuffer))) return $0934e0939605d48c$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === \"number\") throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $0934e0939605d48c$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $0934e0939605d48c$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") return $0934e0939605d48c$var$Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $0934e0939605d48c$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $0934e0939605d48c$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($0934e0939605d48c$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($0934e0939605d48c$var$Buffer, Uint8Array);\nfunction $0934e0939605d48c$var$assertSize(size) {\n    if (typeof size !== \"number\") throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $0934e0939605d48c$var$alloc(size, fill, encoding) {\n    $0934e0939605d48c$var$assertSize(size);\n    if (size <= 0) return $0934e0939605d48c$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === \"string\" ? $0934e0939605d48c$var$createBuffer(size).fill(fill, encoding) : $0934e0939605d48c$var$createBuffer(size).fill(fill);\n    return $0934e0939605d48c$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $0934e0939605d48c$var$Buffer.alloc = function(size, fill, encoding) {\n    return $0934e0939605d48c$var$alloc(size, fill, encoding);\n};\nfunction $0934e0939605d48c$var$allocUnsafe(size) {\n    $0934e0939605d48c$var$assertSize(size);\n    return $0934e0939605d48c$var$createBuffer(size < 0 ? 0 : $0934e0939605d48c$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $0934e0939605d48c$var$Buffer.allocUnsafe = function(size) {\n    return $0934e0939605d48c$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $0934e0939605d48c$var$Buffer.allocUnsafeSlow = function(size) {\n    return $0934e0939605d48c$var$allocUnsafe(size);\n};\nfunction $0934e0939605d48c$var$fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") encoding = \"utf8\";\n    if (!$0934e0939605d48c$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n    const length = $0934e0939605d48c$var$byteLength(string, encoding) | 0;\n    let buf = $0934e0939605d48c$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $0934e0939605d48c$var$checked(array.length) | 0;\n    const buf = $0934e0939605d48c$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromArrayView(arrayView) {\n    if ($0934e0939605d48c$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $0934e0939605d48c$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $0934e0939605d48c$var$fromArrayLike(arrayView);\n}\nfunction $0934e0939605d48c$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $0934e0939605d48c$var$Buffer.prototype);\n    return buf;\n}\nfunction $0934e0939605d48c$var$fromObject(obj) {\n    if ($0934e0939605d48c$var$Buffer.isBuffer(obj)) {\n        const len = $0934e0939605d48c$var$checked(obj.length) | 0;\n        const buf = $0934e0939605d48c$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== \"number\" || $0934e0939605d48c$var$numberIsNaN(obj.length)) return $0934e0939605d48c$var$createBuffer(0);\n        return $0934e0939605d48c$var$fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) return $0934e0939605d48c$var$fromArrayLike(obj.data);\n}\nfunction $0934e0939605d48c$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $0934e0939605d48c$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $0934e0939605d48c$var$K_MAX_LENGTH.toString(16) + \" bytes\");\n    return length | 0;\n}\nfunction $0934e0939605d48c$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $0934e0939605d48c$var$Buffer.alloc(+length);\n}\n$0934e0939605d48c$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $0934e0939605d48c$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$0934e0939605d48c$var$Buffer.compare = function compare(a, b) {\n    if ($0934e0939605d48c$var$isInstance(a, Uint8Array)) a = $0934e0939605d48c$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($0934e0939605d48c$var$isInstance(b, Uint8Array)) b = $0934e0939605d48c$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(a) || !$0934e0939605d48c$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$0934e0939605d48c$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\n$0934e0939605d48c$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $0934e0939605d48c$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $0934e0939605d48c$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($0934e0939605d48c$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) buf = $0934e0939605d48c$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $0934e0939605d48c$var$byteLength(string, encoding) {\n    if ($0934e0939605d48c$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $0934e0939605d48c$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== \"string\") throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return len;\n        case \"utf8\":\n        case \"utf-8\":\n            return $0934e0939605d48c$var$utf8ToBytes(string).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return len * 2;\n        case \"hex\":\n            return len >>> 1;\n        case \"base64\":\n            return $0934e0939605d48c$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $0934e0939605d48c$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$0934e0939605d48c$var$Buffer.byteLength = $0934e0939605d48c$var$byteLength;\nfunction $0934e0939605d48c$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return \"\";\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return \"\";\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return \"\";\n    if (!encoding) encoding = \"utf8\";\n    while(true)switch(encoding){\n        case \"hex\":\n            return $0934e0939605d48c$var$hexSlice(this, start, end);\n        case \"utf8\":\n        case \"utf-8\":\n            return $0934e0939605d48c$var$utf8Slice(this, start, end);\n        case \"ascii\":\n            return $0934e0939605d48c$var$asciiSlice(this, start, end);\n        case \"latin1\":\n        case \"binary\":\n            return $0934e0939605d48c$var$latin1Slice(this, start, end);\n        case \"base64\":\n            return $0934e0939605d48c$var$base64Slice(this, start, end);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $0934e0939605d48c$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$0934e0939605d48c$var$Buffer.prototype._isBuffer = true;\nfunction $0934e0939605d48c$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$0934e0939605d48c$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for(let i = 0; i < len; i += 2)$0934e0939605d48c$var$swap(this, i, i + 1);\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for(let i = 0; i < len; i += 4){\n        $0934e0939605d48c$var$swap(this, i, i + 3);\n        $0934e0939605d48c$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for(let i = 0; i < len; i += 8){\n        $0934e0939605d48c$var$swap(this, i, i + 7);\n        $0934e0939605d48c$var$swap(this, i + 1, i + 6);\n        $0934e0939605d48c$var$swap(this, i + 2, i + 5);\n        $0934e0939605d48c$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$0934e0939605d48c$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return $0934e0939605d48c$var$utf8Slice(this, 0, length);\n    return $0934e0939605d48c$var$slowToString.apply(this, arguments);\n};\n$0934e0939605d48c$var$Buffer.prototype.toLocaleString = $0934e0939605d48c$var$Buffer.prototype.toString;\n$0934e0939605d48c$var$Buffer.prototype.equals = function equals(b) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return $0934e0939605d48c$var$Buffer.compare(this, b) === 0;\n};\n$0934e0939605d48c$var$Buffer.prototype.inspect = function inspect() {\n    let str = \"\";\n    const max = $0934e0939605d48c$export$f99ded8fe4b79145;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max) str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n};\nif ($0934e0939605d48c$var$customInspectSymbol) $0934e0939605d48c$var$Buffer.prototype[$0934e0939605d48c$var$customInspectSymbol] = $0934e0939605d48c$var$Buffer.prototype.inspect;\n$0934e0939605d48c$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($0934e0939605d48c$var$isInstance(target, Uint8Array)) target = $0934e0939605d48c$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError(\"out of range index\");\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $0934e0939605d48c$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($0934e0939605d48c$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") val = $0934e0939605d48c$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($0934e0939605d48c$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $0934e0939605d48c$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $0934e0939605d48c$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction $0934e0939605d48c$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$0934e0939605d48c$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$0934e0939605d48c$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $0934e0939605d48c$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$0934e0939605d48c$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $0934e0939605d48c$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $0934e0939605d48c$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($0934e0939605d48c$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $0934e0939605d48c$var$utf8Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$asciiWrite(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$base64Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $0934e0939605d48c$var$ucs2Write(buf, string, offset, length) {\n    return $0934e0939605d48c$var$blitBuffer($0934e0939605d48c$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$0934e0939605d48c$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    if (!encoding) encoding = \"utf8\";\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case \"hex\":\n            return $0934e0939605d48c$var$hexWrite(this, string, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n            return $0934e0939605d48c$var$utf8Write(this, string, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return $0934e0939605d48c$var$asciiWrite(this, string, offset, length);\n        case \"base64\":\n            // Warning: maxLength not taken into account in base64Write\n            return $0934e0939605d48c$var$base64Write(this, string, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return $0934e0939605d48c$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$0934e0939605d48c$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $0934e0939605d48c$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $8a0a73e6b73fd0c4$export$6100ba28696e12de(buf);\n    else return $8a0a73e6b73fd0c4$export$6100ba28696e12de(buf.slice(start, end));\n}\nfunction $0934e0939605d48c$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $0934e0939605d48c$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $0934e0939605d48c$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = \"\";\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $0934e0939605d48c$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $0934e0939605d48c$var$asciiSlice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $0934e0939605d48c$var$latin1Slice(buf, start, end) {\n    let ret = \"\";\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $0934e0939605d48c$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = \"\";\n    for(let i = start; i < end; ++i)out += $0934e0939605d48c$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $0934e0939605d48c$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = \"\";\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$0934e0939605d48c$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $0934e0939605d48c$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $0934e0939605d48c$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\n$0934e0939605d48c$var$Buffer.prototype.readUintLE = $0934e0939605d48c$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUintBE = $0934e0939605d48c$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint8 = $0934e0939605d48c$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint16LE = $0934e0939605d48c$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint16BE = $0934e0939605d48c$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint32LE = $0934e0939605d48c$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$0934e0939605d48c$var$Buffer.prototype.readUint32BE = $0934e0939605d48c$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$0934e0939605d48c$var$Buffer.prototype.readBigUInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$0934e0939605d48c$var$Buffer.prototype.readBigUInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$0934e0939605d48c$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$0934e0939605d48c$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$0934e0939605d48c$var$Buffer.prototype.readBigInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$0934e0939605d48c$var$Buffer.prototype.readBigInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $0934e0939605d48c$var$validateNumber(offset, \"offset\");\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $0934e0939605d48c$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$0934e0939605d48c$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return $998eb38f4d082829$export$aafa59e2e03f2942(this, offset, true, 23, 4);\n};\n$0934e0939605d48c$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 4, this.length);\n    return $998eb38f4d082829$export$aafa59e2e03f2942(this, offset, false, 23, 4);\n};\n$0934e0939605d48c$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 8, this.length);\n    return $998eb38f4d082829$export$aafa59e2e03f2942(this, offset, true, 52, 8);\n};\n$0934e0939605d48c$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkOffset(offset, 8, this.length);\n    return $998eb38f4d082829$export$aafa59e2e03f2942(this, offset, false, 52, 8);\n};\nfunction $0934e0939605d48c$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\n$0934e0939605d48c$var$Buffer.prototype.writeUintLE = $0934e0939605d48c$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUintBE = $0934e0939605d48c$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint8 = $0934e0939605d48c$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint16LE = $0934e0939605d48c$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint16BE = $0934e0939605d48c$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint32LE = $0934e0939605d48c$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeUint32BE = $0934e0939605d48c$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $0934e0939605d48c$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $0934e0939605d48c$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeBigUInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeBigUInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $0934e0939605d48c$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$0934e0939605d48c$var$Buffer.prototype.writeBigInt64LE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\n$0934e0939605d48c$var$Buffer.prototype.writeBigInt64BE = $0934e0939605d48c$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $0934e0939605d48c$var$wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n});\nfunction $0934e0939605d48c$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction $0934e0939605d48c$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $998eb38f4d082829$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeFloat(this, value, offset, true, noAssert);\n};\n$0934e0939605d48c$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $0934e0939605d48c$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $0934e0939605d48c$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $998eb38f4d082829$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$0934e0939605d48c$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeDouble(this, value, offset, true, noAssert);\n};\n$0934e0939605d48c$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $0934e0939605d48c$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$0934e0939605d48c$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$0934e0939605d48c$var$Buffer.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$0934e0939605d48c$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") throw new TypeError(\"encoding must be a string\");\n        if (typeof encoding === \"string\" && !$0934e0939605d48c$var$Buffer.isEncoding(encoding)) throw new TypeError(\"Unknown encoding: \" + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === \"number\") val = val & 255;\n    else if (typeof val === \"boolean\") val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError(\"Out of range index\");\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === \"number\") for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $0934e0939605d48c$var$Buffer.isBuffer(val) ? val : $0934e0939605d48c$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $0934e0939605d48c$var$errors = {};\nfunction $0934e0939605d48c$var$E(sym, getMessage, Base) {\n    $0934e0939605d48c$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, \"message\", {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, \"code\", {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$0934e0939605d48c$var$E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return \"Attempt to access memory outside buffer bounds\";\n}, RangeError);\n$0934e0939605d48c$var$E(\"ERR_INVALID_ARG_TYPE\", function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$0934e0939605d48c$var$E(\"ERR_OUT_OF_RANGE\", function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $0934e0939605d48c$var$addNumericalSeparator(String(input));\n    else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $0934e0939605d48c$var$addNumericalSeparator(received);\n        received += \"n\";\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $0934e0939605d48c$var$addNumericalSeparator(val) {\n    let res = \"\";\n    let i = val.length;\n    const start = val[0] === \"-\" ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $0934e0939605d48c$var$checkBounds(buf, offset, byteLength) {\n    $0934e0939605d48c$var$validateNumber(offset, \"offset\");\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $0934e0939605d48c$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $0934e0939605d48c$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n    }\n    $0934e0939605d48c$var$checkBounds(buf, offset, byteLength);\n}\nfunction $0934e0939605d48c$var$validateNumber(value, name) {\n    if (typeof value !== \"number\") throw new $0934e0939605d48c$var$errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n}\nfunction $0934e0939605d48c$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $0934e0939605d48c$var$validateNumber(value, type);\n        throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n    }\n    if (length < 0) throw new $0934e0939605d48c$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $0934e0939605d48c$var$errors.ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $0934e0939605d48c$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $0934e0939605d48c$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split(\"=\")[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($0934e0939605d48c$var$INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + \"=\";\n    return str;\n}\nfunction $0934e0939605d48c$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error(\"Invalid code point\");\n    }\n    return bytes;\n}\nfunction $0934e0939605d48c$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $0934e0939605d48c$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $0934e0939605d48c$var$base64ToBytes(str) {\n    return $8a0a73e6b73fd0c4$export$d622b2ad8d90c771($0934e0939605d48c$var$base64clean(str));\n}\nfunction $0934e0939605d48c$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $0934e0939605d48c$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $0934e0939605d48c$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $0934e0939605d48c$var$hexSliceLookupTable = function() {\n    const alphabet = \"0123456789abcdef\";\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $0934e0939605d48c$var$defineBigIntMethod(fn) {\n    return typeof BigInt === \"undefined\" ? $0934e0939605d48c$var$BufferBigIntNotDefined : fn;\n}\nfunction $0934e0939605d48c$var$BufferBigIntNotDefined() {\n    throw new Error(\"BigInt not supported\");\n}\n\n\nvar $39570e0c51fe4cb5$require$Buffer = $0934e0939605d48c$export$a143d493d941bafc;\nvar $39570e0c51fe4cb5$var$atob = function atob(s) {\n    return (0, (/*@__PURE__*/$parcel$interopDefault($d154510a897fbed3$exports))).atob ? (0, (/*@__PURE__*/$parcel$interopDefault($d154510a897fbed3$exports))).atob(s) : $39570e0c51fe4cb5$require$Buffer.from(s, \"base64\").toString(\"binary\");\n};\nfunction $39570e0c51fe4cb5$export$2e2bcd8739ae039(b64Text) {\n    var decodedString = $39570e0c51fe4cb5$var$atob(b64Text);\n    var array = new Uint8Array(decodedString.length);\n    for(var i = 0; i < decodedString.length; i++)array[i] = decodedString.charCodeAt(i);\n    return array;\n}\n\n\n/**\n * @file m3u8/line-stream.js\n */ /**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */ class $d9ac9c5d7f472999$export$307ab5c52b11c33e extends (0, $240ec63f2cada8d3$export$2e2bcd8739ae039) {\n    constructor(){\n        super();\n        this.buffer = \"\";\n    }\n    /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */ push(data) {\n        let nextNewline;\n        this.buffer += data;\n        nextNewline = this.buffer.indexOf(\"\\n\");\n        for(; nextNewline > -1; nextNewline = this.buffer.indexOf(\"\\n\")){\n            this.trigger(\"data\", this.buffer.substring(0, nextNewline));\n            this.buffer = this.buffer.substring(nextNewline + 1);\n        }\n    }\n}\nconst $d9ac9c5d7f472999$var$TAB = String.fromCharCode(0x09);\nconst $d9ac9c5d7f472999$var$parseByterange = function(byterangeString) {\n    // optionally match and capture 0+ digits before `@`\n    // optionally match and capture 0+ digits after `@`\n    const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || \"\");\n    const result = {};\n    if (match[1]) result.length = parseInt(match[1], 10);\n    if (match[2]) result.offset = parseInt(match[2], 10);\n    return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */ const $d9ac9c5d7f472999$var$attributeSeparator = function() {\n    const key = \"[^=]*\";\n    const value = '\"[^\"]*\"|[^,]*';\n    const keyvalue = \"(?:\" + key + \")=(?:\" + value + \")\";\n    return new RegExp(\"(?:^|,)(\" + keyvalue + \")\");\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */ const $d9ac9c5d7f472999$var$parseAttributes = function(attributes) {\n    const result = {};\n    if (!attributes) return result;\n     // split the string using attributes as the separator\n    const attrs = attributes.split($d9ac9c5d7f472999$var$attributeSeparator());\n    let i = attrs.length;\n    let attr;\n    while(i--){\n        // filter out unmatched portions of the string\n        if (attrs[i] === \"\") continue;\n         // split the key and value\n        attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n        attr[0] = attr[0].replace(/^\\s+|\\s+$/g, \"\");\n        attr[1] = attr[1].replace(/^\\s+|\\s+$/g, \"\");\n        attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, \"$1\");\n        result[attr[0]] = attr[1];\n    }\n    return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */ class $d9ac9c5d7f472999$export$bc65cb5a6d9da573 extends (0, $240ec63f2cada8d3$export$2e2bcd8739ae039) {\n    constructor(){\n        super();\n        this.customParsers = [];\n        this.tagMappers = [];\n    }\n    /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */ push(line) {\n        let match;\n        let event; // strip whitespace\n        line = line.trim();\n        if (line.length === 0) // ignore empty lines\n        return;\n         // URIs\n        if (line[0] !== \"#\") {\n            this.trigger(\"data\", {\n                type: \"uri\",\n                uri: line\n            });\n            return;\n        } // map tags\n        const newLines = this.tagMappers.reduce((acc, mapper)=>{\n            const mappedLine = mapper(line); // skip if unchanged\n            if (mappedLine === line) return acc;\n            return acc.concat([\n                mappedLine\n            ]);\n        }, [\n            line\n        ]);\n        newLines.forEach((newLine)=>{\n            for(let i = 0; i < this.customParsers.length; i++){\n                if (this.customParsers[i].call(this, newLine)) return;\n            } // Comments\n            if (newLine.indexOf(\"#EXT\") !== 0) {\n                this.trigger(\"data\", {\n                    type: \"comment\",\n                    text: newLine.slice(1)\n                });\n                return;\n            } // strip off any carriage returns here so the regex matching\n            // doesn't have to account for them.\n            newLine = newLine.replace(\"\\r\", \"\"); // Tags\n            match = /^#EXTM3U/.exec(newLine);\n            if (match) {\n                this.trigger(\"data\", {\n                    type: \"tag\",\n                    tagType: \"m3u\"\n                });\n                return;\n            }\n            match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"inf\"\n                };\n                if (match[1]) event.duration = parseFloat(match[1]);\n                if (match[2]) event.title = match[2];\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"targetduration\"\n                };\n                if (match[1]) event.duration = parseInt(match[1], 10);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"version\"\n                };\n                if (match[1]) event.version = parseInt(match[1], 10);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"media-sequence\"\n                };\n                if (match[1]) event.number = parseInt(match[1], 10);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"discontinuity-sequence\"\n                };\n                if (match[1]) event.number = parseInt(match[1], 10);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"playlist-type\"\n                };\n                if (match[1]) event.playlistType = match[1];\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n            if (match) {\n                event = (0, (/*@__PURE__*/$parcel$interopDefault($fbb6a7bc8836e7ee$exports)))($d9ac9c5d7f472999$var$parseByterange(match[1]), {\n                    type: \"tag\",\n                    tagType: \"byterange\"\n                });\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"allow-cache\"\n                };\n                if (match[1]) event.allowed = !/NO/.test(match[1]);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"map\"\n                };\n                if (match[1]) {\n                    const attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                    if (attributes.URI) event.uri = attributes.URI;\n                    if (attributes.BYTERANGE) event.byterange = $d9ac9c5d7f472999$var$parseByterange(attributes.BYTERANGE);\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"stream-inf\"\n                };\n                if (match[1]) {\n                    event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                    if (event.attributes.RESOLUTION) {\n                        const split = event.attributes.RESOLUTION.split(\"x\");\n                        const resolution = {};\n                        if (split[0]) resolution.width = parseInt(split[0], 10);\n                        if (split[1]) resolution.height = parseInt(split[1], 10);\n                        event.attributes.RESOLUTION = resolution;\n                    }\n                    if (event.attributes.BANDWIDTH) event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n                    if (event.attributes[\"FRAME-RATE\"]) event.attributes[\"FRAME-RATE\"] = parseFloat(event.attributes[\"FRAME-RATE\"]);\n                    if (event.attributes[\"PROGRAM-ID\"]) event.attributes[\"PROGRAM-ID\"] = parseInt(event.attributes[\"PROGRAM-ID\"], 10);\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"media\"\n                };\n                if (match[1]) event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-ENDLIST/.exec(newLine);\n            if (match) {\n                this.trigger(\"data\", {\n                    type: \"tag\",\n                    tagType: \"endlist\"\n                });\n                return;\n            }\n            match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n            if (match) {\n                this.trigger(\"data\", {\n                    type: \"tag\",\n                    tagType: \"discontinuity\"\n                });\n                return;\n            }\n            match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"program-date-time\"\n                };\n                if (match[1]) {\n                    event.dateTimeString = match[1];\n                    event.dateTimeObject = new Date(match[1]);\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"key\"\n                };\n                if (match[1]) {\n                    event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]); // parse the IV string into a Uint32Array\n                    if (event.attributes.IV) {\n                        if (event.attributes.IV.substring(0, 2).toLowerCase() === \"0x\") event.attributes.IV = event.attributes.IV.substring(2);\n                        event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n                        event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n                        event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n                        event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n                        event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n                        event.attributes.IV = new Uint32Array(event.attributes.IV);\n                    }\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-START:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"start\"\n                };\n                if (match[1]) {\n                    event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                    event.attributes[\"TIME-OFFSET\"] = parseFloat(event.attributes[\"TIME-OFFSET\"]);\n                    event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"cue-out-cont\"\n                };\n                if (match[1]) event.data = match[1];\n                else event.data = \"\";\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"cue-out\"\n                };\n                if (match[1]) event.data = match[1];\n                else event.data = \"\";\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"cue-in\"\n                };\n                if (match[1]) event.data = match[1];\n                else event.data = \"\";\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"skip\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                if (event.attributes.hasOwnProperty(\"SKIPPED-SEGMENTS\")) event.attributes[\"SKIPPED-SEGMENTS\"] = parseInt(event.attributes[\"SKIPPED-SEGMENTS\"], 10);\n                if (event.attributes.hasOwnProperty(\"RECENTLY-REMOVED-DATERANGES\")) event.attributes[\"RECENTLY-REMOVED-DATERANGES\"] = event.attributes[\"RECENTLY-REMOVED-DATERANGES\"].split($d9ac9c5d7f472999$var$TAB);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"part\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"DURATION\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);\n                });\n                [\n                    \"INDEPENDENT\",\n                    \"GAP\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);\n                });\n                if (event.attributes.hasOwnProperty(\"BYTERANGE\")) event.attributes.byterange = $d9ac9c5d7f472999$var$parseByterange(event.attributes.BYTERANGE);\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"server-control\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"CAN-SKIP-UNTIL\",\n                    \"PART-HOLD-BACK\",\n                    \"HOLD-BACK\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);\n                });\n                [\n                    \"CAN-SKIP-DATERANGES\",\n                    \"CAN-BLOCK-RELOAD\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);\n                });\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"part-inf\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"PART-TARGET\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);\n                });\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"preload-hint\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"BYTERANGE-START\",\n                    \"BYTERANGE-LENGTH\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) {\n                        event.attributes[key] = parseInt(event.attributes[key], 10);\n                        const subkey = key === \"BYTERANGE-LENGTH\" ? \"length\" : \"offset\";\n                        event.attributes.byterange = event.attributes.byterange || {};\n                        event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n                        delete event.attributes[key];\n                    }\n                });\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"rendition-report\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"LAST-MSN\",\n                    \"LAST-PART\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseInt(event.attributes[key], 10);\n                });\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n            if (match && match[1]) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"daterange\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                [\n                    \"ID\",\n                    \"CLASS\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = String(event.attributes[key]);\n                });\n                [\n                    \"START-DATE\",\n                    \"END-DATE\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = new Date(event.attributes[key]);\n                });\n                [\n                    \"DURATION\",\n                    \"PLANNED-DURATION\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);\n                });\n                [\n                    \"END-ON-NEXT\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/i.test(event.attributes[key]);\n                });\n                [\n                    \"SCTE35-CMD\",\n                    \" SCTE35-OUT\",\n                    \"SCTE35-IN\"\n                ].forEach(function(key) {\n                    if (event.attributes.hasOwnProperty(key)) event.attributes[key] = event.attributes[key].toString(16);\n                });\n                const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n                for(const key in event.attributes){\n                    if (!clientAttributePattern.test(key)) continue;\n                    const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n                    const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n                    event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n                }\n                this.trigger(\"data\", event);\n                return;\n            }\n            match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n            if (match) {\n                this.trigger(\"data\", {\n                    type: \"tag\",\n                    tagType: \"independent-segments\"\n                });\n                return;\n            }\n            match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n            if (match) {\n                event = {\n                    type: \"tag\",\n                    tagType: \"content-steering\"\n                };\n                event.attributes = $d9ac9c5d7f472999$var$parseAttributes(match[1]);\n                this.trigger(\"data\", event);\n                return;\n            } // unknown tag type\n            this.trigger(\"data\", {\n                type: \"tag\",\n                data: newLine.slice(4)\n            });\n        });\n    }\n    /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */ addParser({ expression: expression, customType: customType, dataParser: dataParser, segment: segment }) {\n        if (typeof dataParser !== \"function\") dataParser = (line)=>line;\n        this.customParsers.push((line)=>{\n            const match = expression.exec(line);\n            if (match) {\n                this.trigger(\"data\", {\n                    type: \"custom\",\n                    data: dataParser(line),\n                    customType: customType,\n                    segment: segment\n                });\n                return true;\n            }\n        });\n    }\n    /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */ addTagMapper({ expression: expression, map: map }) {\n        const mapFn = (line)=>{\n            if (expression.test(line)) return map(line);\n            return line;\n        };\n        this.tagMappers.push(mapFn);\n    }\n}\nconst $d9ac9c5d7f472999$var$camelCase = (str)=>str.toLowerCase().replace(/-(\\w)/g, (a)=>a[1].toUpperCase());\nconst $d9ac9c5d7f472999$var$camelCaseKeys = function(attributes) {\n    const result = {};\n    Object.keys(attributes).forEach(function(key) {\n        result[$d9ac9c5d7f472999$var$camelCase(key)] = attributes[key];\n    });\n    return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\nconst $d9ac9c5d7f472999$var$setHoldBack = function(manifest) {\n    const { serverControl: serverControl, targetDuration: targetDuration, partTargetDuration: partTargetDuration } = manifest;\n    if (!serverControl) return;\n    const tag = \"#EXT-X-SERVER-CONTROL\";\n    const hb = \"holdBack\";\n    const phb = \"partHoldBack\";\n    const minTargetDuration = targetDuration && targetDuration * 3;\n    const minPartDuration = partTargetDuration && partTargetDuration * 2;\n    if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n        serverControl[hb] = minTargetDuration;\n        this.trigger(\"info\", {\n            message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n        });\n    }\n    if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n        this.trigger(\"warn\", {\n            message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n        });\n        serverControl[hb] = minTargetDuration;\n    } // default no part hold back to part target duration * 3\n    if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n        serverControl[phb] = partTargetDuration * 3;\n        this.trigger(\"info\", {\n            message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n        });\n    } // if part hold back is too small default it to part target duration * 2\n    if (partTargetDuration && serverControl[phb] < minPartDuration) {\n        this.trigger(\"warn\", {\n            message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n        });\n        serverControl[phb] = minPartDuration;\n    }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */ class $d9ac9c5d7f472999$export$7acfa6ed01010e37 extends (0, $240ec63f2cada8d3$export$2e2bcd8739ae039) {\n    constructor(){\n        super();\n        this.lineStream = new $d9ac9c5d7f472999$export$307ab5c52b11c33e();\n        this.parseStream = new $d9ac9c5d7f472999$export$bc65cb5a6d9da573();\n        this.lineStream.pipe(this.parseStream);\n        this.lastProgramDateTime = null;\n        /* eslint-disable consistent-this */ const self = this;\n        /* eslint-enable consistent-this */ const uris = [];\n        let currentUri = {}; // if specified, the active EXT-X-MAP definition\n        let currentMap; // if specified, the active decryption key\n        let key;\n        let hasParts = false;\n        const noop = function() {};\n        const defaultMediaGroups = {\n            \"AUDIO\": {},\n            \"VIDEO\": {},\n            \"CLOSED-CAPTIONS\": {},\n            \"SUBTITLES\": {}\n        }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n        // used in MPDs with Widevine encrypted streams.\n        const widevineUuid = \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"; // group segments into numbered timelines delineated by discontinuities\n        let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n        this.manifest = {\n            allowCache: true,\n            discontinuityStarts: [],\n            dateRanges: [],\n            segments: []\n        }; // keep track of the last seen segment's byte range end, as segments are not required\n        // to provide the offset, in which case it defaults to the next byte after the\n        // previous segment\n        let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n        let lastPartByterangeEnd = 0;\n        const dateRangeTags = {};\n        this.on(\"end\", ()=>{\n            // only add preloadSegment if we don't yet have a uri for it.\n            // and we actually have parts/preloadHints\n            if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) return;\n            if (!currentUri.map && currentMap) currentUri.map = currentMap;\n            if (!currentUri.key && key) currentUri.key = key;\n            if (!currentUri.timeline && typeof currentTimeline === \"number\") currentUri.timeline = currentTimeline;\n            this.manifest.preloadSegment = currentUri;\n        }); // update the manifest with the m3u8 entry from the parse stream\n        this.parseStream.on(\"data\", function(entry) {\n            let mediaGroup;\n            let rendition;\n            ({\n                tag () {\n                    // switch based on the tag type\n                    (({\n                        version () {\n                            if (entry.version) this.manifest.version = entry.version;\n                        },\n                        \"allow-cache\" () {\n                            this.manifest.allowCache = entry.allowed;\n                            if (!(\"allowed\" in entry)) {\n                                this.trigger(\"info\", {\n                                    message: \"defaulting allowCache to YES\"\n                                });\n                                this.manifest.allowCache = true;\n                            }\n                        },\n                        byterange () {\n                            const byterange = {};\n                            if (\"length\" in entry) {\n                                currentUri.byterange = byterange;\n                                byterange.length = entry.length;\n                                if (!(\"offset\" in entry)) /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */ entry.offset = lastByterangeEnd;\n                            }\n                            if (\"offset\" in entry) {\n                                currentUri.byterange = byterange;\n                                byterange.offset = entry.offset;\n                            }\n                            lastByterangeEnd = byterange.offset + byterange.length;\n                        },\n                        endlist () {\n                            this.manifest.endList = true;\n                        },\n                        inf () {\n                            if (!(\"mediaSequence\" in this.manifest)) {\n                                this.manifest.mediaSequence = 0;\n                                this.trigger(\"info\", {\n                                    message: \"defaulting media sequence to zero\"\n                                });\n                            }\n                            if (!(\"discontinuitySequence\" in this.manifest)) {\n                                this.manifest.discontinuitySequence = 0;\n                                this.trigger(\"info\", {\n                                    message: \"defaulting discontinuity sequence to zero\"\n                                });\n                            }\n                            if (entry.title) currentUri.title = entry.title;\n                            if (entry.duration > 0) currentUri.duration = entry.duration;\n                            if (entry.duration === 0) {\n                                currentUri.duration = 0.01;\n                                this.trigger(\"info\", {\n                                    message: \"updating zero segment duration to a small value\"\n                                });\n                            }\n                            this.manifest.segments = uris;\n                        },\n                        key () {\n                            if (!entry.attributes) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring key declaration without attribute list\"\n                                });\n                                return;\n                            } // clear the active encryption key\n                            if (entry.attributes.METHOD === \"NONE\") {\n                                key = null;\n                                return;\n                            }\n                            if (!entry.attributes.URI) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring key declaration without URI\"\n                                });\n                                return;\n                            }\n                            if (entry.attributes.KEYFORMAT === \"com.apple.streamingkeydelivery\") {\n                                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n                                this.manifest.contentProtection[\"com.apple.fps.1_0\"] = {\n                                    attributes: entry.attributes\n                                };\n                                return;\n                            }\n                            if (entry.attributes.KEYFORMAT === \"com.microsoft.playready\") {\n                                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n                                this.manifest.contentProtection[\"com.microsoft.playready\"] = {\n                                    uri: entry.attributes.URI\n                                };\n                                return;\n                            } // check if the content is encrypted for Widevine\n                            // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n                            if (entry.attributes.KEYFORMAT === widevineUuid) {\n                                const VALID_METHODS = [\n                                    \"SAMPLE-AES\",\n                                    \"SAMPLE-AES-CTR\",\n                                    \"SAMPLE-AES-CENC\"\n                                ];\n                                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                                    this.trigger(\"warn\", {\n                                        message: \"invalid key method provided for Widevine\"\n                                    });\n                                    return;\n                                }\n                                if (entry.attributes.METHOD === \"SAMPLE-AES-CENC\") this.trigger(\"warn\", {\n                                    message: \"SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead\"\n                                });\n                                if (entry.attributes.URI.substring(0, 23) !== \"data:text/plain;base64,\") {\n                                    this.trigger(\"warn\", {\n                                        message: \"invalid key URI provided for Widevine\"\n                                    });\n                                    return;\n                                }\n                                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === \"0x\")) {\n                                    this.trigger(\"warn\", {\n                                        message: \"invalid key ID provided for Widevine\"\n                                    });\n                                    return;\n                                } // if Widevine key attributes are valid, store them as `contentProtection`\n                                // on the manifest to emulate Widevine tag structure in a DASH mpd\n                                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                                this.manifest.contentProtection[\"com.widevine.alpha\"] = {\n                                    attributes: {\n                                        schemeIdUri: entry.attributes.KEYFORMAT,\n                                        // remove '0x' from the key id string\n                                        keyId: entry.attributes.KEYID.substring(2)\n                                    },\n                                    // decode the base64-encoded PSSH box\n                                    pssh: (0, $39570e0c51fe4cb5$export$2e2bcd8739ae039)(entry.attributes.URI.split(\",\")[1])\n                                };\n                                return;\n                            }\n                            if (!entry.attributes.METHOD) this.trigger(\"warn\", {\n                                message: \"defaulting key method to AES-128\"\n                            });\n                             // setup an encryption key for upcoming segments\n                            key = {\n                                method: entry.attributes.METHOD || \"AES-128\",\n                                uri: entry.attributes.URI\n                            };\n                            if (typeof entry.attributes.IV !== \"undefined\") key.iv = entry.attributes.IV;\n                        },\n                        \"media-sequence\" () {\n                            if (!isFinite(entry.number)) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring invalid media sequence: \" + entry.number\n                                });\n                                return;\n                            }\n                            this.manifest.mediaSequence = entry.number;\n                        },\n                        \"discontinuity-sequence\" () {\n                            if (!isFinite(entry.number)) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring invalid discontinuity sequence: \" + entry.number\n                                });\n                                return;\n                            }\n                            this.manifest.discontinuitySequence = entry.number;\n                            currentTimeline = entry.number;\n                        },\n                        \"playlist-type\" () {\n                            if (!/VOD|EVENT/.test(entry.playlistType)) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring unknown playlist type: \" + entry.playlist\n                                });\n                                return;\n                            }\n                            this.manifest.playlistType = entry.playlistType;\n                        },\n                        map () {\n                            currentMap = {};\n                            if (entry.uri) currentMap.uri = entry.uri;\n                            if (entry.byterange) currentMap.byterange = entry.byterange;\n                            if (key) currentMap.key = key;\n                        },\n                        \"stream-inf\" () {\n                            this.manifest.playlists = uris;\n                            this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                            if (!entry.attributes) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring empty stream-inf attributes\"\n                                });\n                                return;\n                            }\n                            if (!currentUri.attributes) currentUri.attributes = {};\n                            (0, (/*@__PURE__*/$parcel$interopDefault($fbb6a7bc8836e7ee$exports)))(currentUri.attributes, entry.attributes);\n                        },\n                        media () {\n                            this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                            if (!(entry.attributes && entry.attributes.TYPE && entry.attributes[\"GROUP-ID\"] && entry.attributes.NAME)) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring incomplete or missing media group\"\n                                });\n                                return;\n                            } // find the media group, creating defaults as necessary\n                            const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n                            mediaGroupType[entry.attributes[\"GROUP-ID\"]] = mediaGroupType[entry.attributes[\"GROUP-ID\"]] || {};\n                            mediaGroup = mediaGroupType[entry.attributes[\"GROUP-ID\"]]; // collect the rendition metadata\n                            rendition = {\n                                default: /yes/i.test(entry.attributes.DEFAULT)\n                            };\n                            if (rendition.default) rendition.autoselect = true;\n                            else rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n                            if (entry.attributes.LANGUAGE) rendition.language = entry.attributes.LANGUAGE;\n                            if (entry.attributes.URI) rendition.uri = entry.attributes.URI;\n                            if (entry.attributes[\"INSTREAM-ID\"]) rendition.instreamId = entry.attributes[\"INSTREAM-ID\"];\n                            if (entry.attributes.CHARACTERISTICS) rendition.characteristics = entry.attributes.CHARACTERISTICS;\n                            if (entry.attributes.FORCED) rendition.forced = /yes/i.test(entry.attributes.FORCED);\n                             // insert the new rendition\n                            mediaGroup[entry.attributes.NAME] = rendition;\n                        },\n                        discontinuity () {\n                            currentTimeline += 1;\n                            currentUri.discontinuity = true;\n                            this.manifest.discontinuityStarts.push(uris.length);\n                        },\n                        \"program-date-time\" () {\n                            if (typeof this.manifest.dateTimeString === \"undefined\") {\n                                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                                // to the manifest object\n                                // TODO: Consider removing this in future major version\n                                this.manifest.dateTimeString = entry.dateTimeString;\n                                this.manifest.dateTimeObject = entry.dateTimeObject;\n                            }\n                            currentUri.dateTimeString = entry.dateTimeString;\n                            currentUri.dateTimeObject = entry.dateTimeObject;\n                            const { lastProgramDateTime: lastProgramDateTime } = this;\n                            this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n                            // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n                            if (lastProgramDateTime === null) // Extrapolate Program Date Time backward\n                            // Since it is first program date time occurrence we're assuming that\n                            // all this.manifest.segments have no program date time info\n                            this.manifest.segments.reduceRight((programDateTime, segment)=>{\n                                segment.programDateTime = programDateTime - segment.duration * 1000;\n                                return segment.programDateTime;\n                            }, this.lastProgramDateTime);\n                        },\n                        targetduration () {\n                            if (!isFinite(entry.duration) || entry.duration < 0) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring invalid target duration: \" + entry.duration\n                                });\n                                return;\n                            }\n                            this.manifest.targetDuration = entry.duration;\n                            $d9ac9c5d7f472999$var$setHoldBack.call(this, this.manifest);\n                        },\n                        start () {\n                            if (!entry.attributes || isNaN(entry.attributes[\"TIME-OFFSET\"])) {\n                                this.trigger(\"warn\", {\n                                    message: \"ignoring start declaration without appropriate attribute list\"\n                                });\n                                return;\n                            }\n                            this.manifest.start = {\n                                timeOffset: entry.attributes[\"TIME-OFFSET\"],\n                                precise: entry.attributes.PRECISE\n                            };\n                        },\n                        \"cue-out\" () {\n                            currentUri.cueOut = entry.data;\n                        },\n                        \"cue-out-cont\" () {\n                            currentUri.cueOutCont = entry.data;\n                        },\n                        \"cue-in\" () {\n                            currentUri.cueIn = entry.data;\n                        },\n                        \"skip\" () {\n                            this.manifest.skip = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            this.warnOnMissingAttributes_(\"#EXT-X-SKIP\", entry.attributes, [\n                                \"SKIPPED-SEGMENTS\"\n                            ]);\n                        },\n                        \"part\" () {\n                            hasParts = true; // parts are always specifed before a segment\n                            const segmentIndex = this.manifest.segments.length;\n                            const part = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            currentUri.parts = currentUri.parts || [];\n                            currentUri.parts.push(part);\n                            if (part.byterange) {\n                                if (!part.byterange.hasOwnProperty(\"offset\")) part.byterange.offset = lastPartByterangeEnd;\n                                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n                            }\n                            const partIndex = currentUri.parts.length - 1;\n                            this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, [\n                                \"URI\",\n                                \"DURATION\"\n                            ]);\n                            if (this.manifest.renditionReports) this.manifest.renditionReports.forEach((r, i)=>{\n                                if (!r.hasOwnProperty(\"lastPart\")) this.trigger(\"warn\", {\n                                    message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                                });\n                            });\n                        },\n                        \"server-control\" () {\n                            const attrs = this.manifest.serverControl = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            if (!attrs.hasOwnProperty(\"canBlockReload\")) {\n                                attrs.canBlockReload = false;\n                                this.trigger(\"info\", {\n                                    message: \"#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false\"\n                                });\n                            }\n                            $d9ac9c5d7f472999$var$setHoldBack.call(this, this.manifest);\n                            if (attrs.canSkipDateranges && !attrs.hasOwnProperty(\"canSkipUntil\")) this.trigger(\"warn\", {\n                                message: \"#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set\"\n                            });\n                        },\n                        \"preload-hint\" () {\n                            // parts are always specifed before a segment\n                            const segmentIndex = this.manifest.segments.length;\n                            const hint = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            const isPart = hint.type && hint.type === \"PART\";\n                            currentUri.preloadHints = currentUri.preloadHints || [];\n                            currentUri.preloadHints.push(hint);\n                            if (hint.byterange) {\n                                if (!hint.byterange.hasOwnProperty(\"offset\")) {\n                                    // use last part byterange end or zero if not a part.\n                                    hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n                                    if (isPart) lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                                }\n                            }\n                            const index = currentUri.preloadHints.length - 1;\n                            this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, [\n                                \"TYPE\",\n                                \"URI\"\n                            ]);\n                            if (!hint.type) return;\n                             // search through all preload hints except for the current one for\n                            // a duplicate type.\n                            for(let i = 0; i < currentUri.preloadHints.length - 1; i++){\n                                const otherHint = currentUri.preloadHints[i];\n                                if (!otherHint.type) continue;\n                                if (otherHint.type === hint.type) this.trigger(\"warn\", {\n                                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                                });\n                            }\n                        },\n                        \"rendition-report\" () {\n                            const report = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            this.manifest.renditionReports = this.manifest.renditionReports || [];\n                            this.manifest.renditionReports.push(report);\n                            const index = this.manifest.renditionReports.length - 1;\n                            const required = [\n                                \"LAST-MSN\",\n                                \"URI\"\n                            ];\n                            if (hasParts) required.push(\"LAST-PART\");\n                            this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n                        },\n                        \"part-inf\" () {\n                            this.manifest.partInf = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            this.warnOnMissingAttributes_(\"#EXT-X-PART-INF\", entry.attributes, [\n                                \"PART-TARGET\"\n                            ]);\n                            if (this.manifest.partInf.partTarget) this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n                            $d9ac9c5d7f472999$var$setHoldBack.call(this, this.manifest);\n                        },\n                        \"daterange\" () {\n                            this.manifest.dateRanges.push($d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes));\n                            const index = this.manifest.dateRanges.length - 1;\n                            this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, [\n                                \"ID\",\n                                \"START-DATE\"\n                            ]);\n                            const dateRange = this.manifest.dateRanges[index];\n                            if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) this.trigger(\"warn\", {\n                                message: \"EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE\"\n                            });\n                            if (dateRange.duration && dateRange.duration < 0) this.trigger(\"warn\", {\n                                message: \"EXT-X-DATERANGE DURATION must not be negative\"\n                            });\n                            if (dateRange.plannedDuration && dateRange.plannedDuration < 0) this.trigger(\"warn\", {\n                                message: \"EXT-X-DATERANGE PLANNED-DURATION must not be negative\"\n                            });\n                            const endOnNextYes = !!dateRange.endOnNext;\n                            if (endOnNextYes && !dateRange.class) this.trigger(\"warn\", {\n                                message: \"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute\"\n                            });\n                            if (endOnNextYes && (dateRange.duration || dateRange.endDate)) this.trigger(\"warn\", {\n                                message: \"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes\"\n                            });\n                            if (dateRange.duration && dateRange.endDate) {\n                                const startDate = dateRange.startDate;\n                                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n                            }\n                            if (!dateRangeTags[dateRange.id]) dateRangeTags[dateRange.id] = dateRange;\n                            else {\n                                for(const attribute in dateRangeTags[dateRange.id])if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                                    this.trigger(\"warn\", {\n                                        message: \"EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values\"\n                                    });\n                                    break;\n                                }\n                                 // if tags with the same ID do not have conflicting attributes, merge them\n                                const dateRangeWithSameId = this.manifest.dateRanges.findIndex((dateRangeToFind)=>dateRangeToFind.id === dateRange.id);\n                                this.manifest.dateRanges[dateRangeWithSameId] = (0, (/*@__PURE__*/$parcel$interopDefault($fbb6a7bc8836e7ee$exports)))(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                                dateRangeTags[dateRange.id] = (0, (/*@__PURE__*/$parcel$interopDefault($fbb6a7bc8836e7ee$exports)))(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n                                this.manifest.dateRanges.pop();\n                            }\n                        },\n                        \"independent-segments\" () {\n                            this.manifest.independentSegments = true;\n                        },\n                        \"content-steering\" () {\n                            this.manifest.contentSteering = $d9ac9c5d7f472999$var$camelCaseKeys(entry.attributes);\n                            this.warnOnMissingAttributes_(\"#EXT-X-CONTENT-STEERING\", entry.attributes, [\n                                \"SERVER-URI\"\n                            ]);\n                        }\n                    })[entry.tagType] || noop).call(self);\n                },\n                uri () {\n                    currentUri.uri = entry.uri;\n                    uris.push(currentUri); // if no explicit duration was declared, use the target duration\n                    if (this.manifest.targetDuration && !(\"duration\" in currentUri)) {\n                        this.trigger(\"warn\", {\n                            message: \"defaulting segment duration to the target duration\"\n                        });\n                        currentUri.duration = this.manifest.targetDuration;\n                    } // annotate with encryption information, if necessary\n                    if (key) currentUri.key = key;\n                    currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n                    if (currentMap) currentUri.map = currentMap;\n                     // reset the last byterange end as it needs to be 0 between parts\n                    lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n                    if (this.lastProgramDateTime !== null) {\n                        currentUri.programDateTime = this.lastProgramDateTime;\n                        this.lastProgramDateTime += currentUri.duration * 1000;\n                    } // prepare for the next URI\n                    currentUri = {};\n                },\n                comment () {},\n                custom () {\n                    // if this is segment-level data attach the output to the segment\n                    if (entry.segment) {\n                        currentUri.custom = currentUri.custom || {};\n                        currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n                    } else {\n                        this.manifest.custom = this.manifest.custom || {};\n                        this.manifest.custom[entry.customType] = entry.data;\n                    }\n                }\n            })[entry.type].call(self);\n        });\n    }\n    warnOnMissingAttributes_(identifier, attributes, required) {\n        const missing = [];\n        required.forEach(function(key) {\n            if (!attributes.hasOwnProperty(key)) missing.push(key);\n        });\n        if (missing.length) this.trigger(\"warn\", {\n            message: `${identifier} lacks required attribute(s): ${missing.join(\", \")}`\n        });\n    }\n    /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */ push(chunk) {\n        this.lineStream.push(chunk);\n    }\n    /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */ end() {\n        // flush any buffered input\n        this.lineStream.push(\"\\n\");\n        if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) this.trigger(\"warn\", {\n            message: \"A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag\"\n        });\n        this.lastProgramDateTime = null;\n        this.trigger(\"end\");\n    }\n    /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */ addParser(options) {\n        this.parseStream.addParser(options);\n    }\n    /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */ addTagMapper(options) {\n        this.parseStream.addTagMapper(options);\n    }\n}\n\n\n// Assign ffmpeg to window.ffmpeg if it doesn't already exist\nwindow.ffmpeg ??= (0, $15cc90f6d9fc0a3d$exports.createFFmpeg)({\n    mainName: \"main\",\n    log: true,\n    corePath: \"https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js\"\n});\n(async ()=>{\n    // Load ffmpeg if it isn't already loaded\n    if (!window.ffmpeg.isLoaded()) await window.ffmpeg.load();\n    // Get the .m3u8 URL from the HTML\n    const m3u8Url = document.querySelector(\"[data-hls-url]\")?.getAttribute(\"data-hls-url\") || document.querySelector(\"shreddit-player source\")?.getAttribute(\"src\");\n    if (!m3u8Url) return;\n    // Fetch and parse the master .m3u8 file\n    const response = await fetch(m3u8Url);\n    const masterPlaylistContent = await response.text();\n    const masterParser = new (0, $d9ac9c5d7f472999$export$7acfa6ed01010e37)();\n    masterParser.push(masterPlaylistContent);\n    masterParser.end();\n    const masterPlaylist = masterParser.manifest;\n    // Display available video and audio options to the user\n    const videoOptions = masterPlaylist.playlists.map((playlist, index)=>{\n        return {\n            index: index,\n            bandwidth: playlist.attributes.BANDWIDTH,\n            resolution: playlist.attributes.RESOLUTION\n        };\n    });\n    const audioOptions = Object.entries(masterPlaylist.mediaGroups.AUDIO).flatMap(([groupId, audios])=>Object.values(audios).map((audio, index)=>({\n                index: index,\n                groupId: groupId,\n                ...audio\n            })));\n    // Find the highest resolution video and the last audio option\n    const defaultVideoIndex = videoOptions.reduce((prev, curr)=>prev.bandwidth > curr.bandwidth ? prev : curr).index;\n    const defaultAudio = audioOptions[audioOptions.length - 1];\n    const defaultAudioIndex = defaultAudio.index;\n    const defaultAudioGroupId = defaultAudio.groupId;\n    // Inject modal dialog HTML and CSS\n    const modalHtml = `\r\n    <div id=\"myModal\" class=\"modal\">\r\n      <div class=\"modal-content\">\r\n        <span class=\"close\">&times;</span>\r\n        <h2>Select Video and Audio Options</h2>\r\n        <label for=\"videoSelect\">Video Options:</label>\r\n        <select id=\"videoSelect\"></select>\r\n        <br>\r\n        <label for=\"audioSelect\">Audio Options:</label>\r\n        <select id=\"audioSelect\"></select>\r\n        <br>\r\n        <button id=\"startButton\">Download</button>\r\n      </div>\r\n    </div>\r\n  `;\n    const modalCss = `\r\n    .modal {\r\n      display: none;\r\n      position: fixed;\r\n      z-index: 1;\r\n      left: 0;\r\n      top: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      overflow: auto;\r\n      background-color: rgb(0,0,0);\r\n      background-color: rgba(0,0,0,0.4);\r\n    }\r\n    .modal-content {\r\n      background-color: #fefefe;\r\n      margin: 15% auto;\r\n      padding: 20px;\r\n      border: 1px solid #888;\r\n      width: 80%;\r\n      max-width: 500px;\r\n    }\r\n    .close {\r\n      color: #aaa;\r\n      float: right;\r\n      font-size: 28px;\r\n      font-weight: bold;\r\n    }\r\n    .close:hover,\r\n    .close:focus {\r\n      color: black;\r\n      text-decoration: none;\r\n      cursor: pointer;\r\n    }\r\n  `;\n    // Append CSS to the document head\n    const style = document.createElement(\"style\");\n    style.innerHTML = modalCss;\n    document.head.appendChild(style);\n    // Append modal HTML to the document body\n    const modal = document.createElement(\"div\");\n    modal.innerHTML = modalHtml;\n    document.body.appendChild(modal);\n    // Populate the video and audio select elements\n    const videoSelect = document.getElementById(\"videoSelect\");\n    videoOptions.forEach((option)=>{\n        const opt = document.createElement(\"option\");\n        opt.value = option.index;\n        opt.textContent = `Bandwidth: ${option.bandwidth}, Resolution: ${option.resolution.width}x${option.resolution.height}`;\n        videoSelect.appendChild(opt);\n    });\n    const audioSelect = document.getElementById(\"audioSelect\");\n    audioOptions.forEach((option)=>{\n        const opt = document.createElement(\"option\");\n        opt.value = JSON.stringify({\n            index: option.index,\n            groupId: option.groupId\n        });\n        opt.textContent = `URI: ${option.uri}`;\n        audioSelect.appendChild(opt);\n    });\n    // Set default selections\n    videoSelect.value = defaultVideoIndex;\n    audioSelect.value = JSON.stringify({\n        index: defaultAudioIndex,\n        groupId: defaultAudioGroupId\n    });\n    // Display the modal\n    const modalElement = document.getElementById(\"myModal\");\n    modalElement.style.display = \"block\";\n    // Close the modal when the user clicks on the close button\n    const closeButton = modalElement.querySelector(\".close\");\n    closeButton.onclick = ()=>modalElement.style.display = \"none\";\n    // Start the download process when the user clicks the start button\n    const startButton = document.getElementById(\"startButton\");\n    startButton.addEventListener(\"click\", async ()=>{\n        const selectedVideoIndex = parseInt(videoSelect.value);\n        const { index: selectedAudioIndex, groupId: selectedAudioGroupId } = JSON.parse(audioSelect.value);\n        const videoVariant = masterPlaylist.playlists[selectedVideoIndex];\n        const audioVariant = Object.values(masterPlaylist.mediaGroups.AUDIO[selectedAudioGroupId])[selectedAudioIndex];\n        console.log(masterPlaylist.mediaGroups.AUDIO, selectedAudioGroupId, selectedAudioIndex);\n        console.log(\"variants\", videoVariant, audioVariant);\n        const videoPlaylistUrl = new URL(videoVariant.uri, m3u8Url).toString();\n        const audioPlaylistUrl = new URL(audioVariant.uri, m3u8Url).toString();\n        // Fetch and parse the video and audio playlists concurrently\n        const [videoPlaylistContent, audioPlaylistContent] = await Promise.all([\n            fetch(videoPlaylistUrl).then((res)=>res.text()),\n            fetch(audioPlaylistUrl).then((res)=>res.text())\n        ]);\n        const videoParser = new (0, $d9ac9c5d7f472999$export$7acfa6ed01010e37)();\n        videoParser.push(videoPlaylistContent);\n        videoParser.end();\n        const videoPlaylist = videoParser.manifest;\n        const audioParser = new (0, $d9ac9c5d7f472999$export$7acfa6ed01010e37)();\n        audioParser.push(audioPlaylistContent);\n        audioParser.end();\n        const audioPlaylist = audioParser.manifest;\n        // Fetch the first segments of video and audio concurrently\n        const [video, audio] = await Promise.all([\n            fetch(new URL(videoPlaylist.segments[0].uri, videoPlaylistUrl)).then((res)=>res.arrayBuffer()).then((buf)=>new Uint8Array(buf)),\n            fetch(new URL(audioPlaylist.segments[0].uri, audioPlaylistUrl)).then((res)=>res.arrayBuffer()).then((buf)=>new Uint8Array(buf))\n        ]);\n        // Determine the segment file extensions\n        const videoExt = videoPlaylist.segments[0].uri.split(\".\").pop();\n        const audioExt = audioPlaylist.segments[0].uri.split(\".\").pop();\n        const videoFileName = `video.${videoExt}`;\n        const audioFileName = `audio.${audioExt}`;\n        // Write video and audio segments to ffmpeg FS\n        await ffmpeg.FS(\"writeFile\", videoFileName, video);\n        await ffmpeg.FS(\"writeFile\", audioFileName, audio);\n        // Merge video and audio segments\n        await ffmpeg.run(\"-i\", videoFileName, \"-i\", audioFileName, \"-c\", \"copy\", \"output.mp4\");\n        const data = ffmpeg.FS(\"readFile\", \"output.mp4\");\n        window.ffmpeg.exit();\n        // Download the file from the buffer\n        const downloadLink = document.createElement(\"a\");\n        downloadLink.href = window.URL.createObjectURL(new Blob([\n            data.buffer\n        ], {\n            type: \"video/mp4\"\n        }));\n        downloadLink.download = `${document.title}.mp4`;\n        document.body.appendChild(downloadLink);\n        downloadLink.click();\n        document.body.removeChild(downloadLink);\n        // Close the modal\n        modalElement.style.display = \"none\";\n    });\n})();\n\n})();\n//# sourceMappingURL=index.js.map\n","import { createFFmpeg } from '@ffmpeg/ffmpeg';\r\nimport { Parser } from 'm3u8-parser';\r\n\r\n// Assign ffmpeg to window.ffmpeg if it doesn't already exist\r\nwindow.ffmpeg ??= createFFmpeg({\r\n  mainName: 'main',\r\n  log: true,\r\n  corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',\r\n});\r\n\r\n(async () => {\r\n  // Load ffmpeg if it isn't already loaded\r\n  if (!window.ffmpeg.isLoaded()) await window.ffmpeg.load();\r\n\r\n  // Get the .m3u8 URL from the HTML\r\n  const m3u8Url = document.querySelector('[data-hls-url]')?.getAttribute('data-hls-url') || document.querySelector('shreddit-player source')?.getAttribute('src');\r\n  if (!m3u8Url) return;\r\n\r\n  // Fetch and parse the master .m3u8 file\r\n  const response = await fetch(m3u8Url);\r\n  const masterPlaylistContent = await response.text();\r\n  const masterParser = new Parser();\r\n  masterParser.push(masterPlaylistContent);\r\n  masterParser.end();\r\n  const masterPlaylist = masterParser.manifest;\r\n\r\n  // Display available video and audio options to the user\r\n  const videoOptions = masterPlaylist.playlists.map((playlist, index) => {\r\n    return { index, bandwidth: playlist.attributes.BANDWIDTH, resolution: playlist.attributes.RESOLUTION };\r\n  });\r\n\r\n  const audioOptions = Object.entries(masterPlaylist.mediaGroups.AUDIO).flatMap(([groupId, audios]) => \r\n    Object.values(audios).map((audio, index) => ({ index, groupId, ...audio }))\r\n  );\r\n\r\n  // Find the highest resolution video and the last audio option\r\n  const defaultVideoIndex = videoOptions.reduce((prev, curr) => (prev.bandwidth > curr.bandwidth ? prev : curr)).index;\r\n  const defaultAudio = audioOptions[audioOptions.length - 1];\r\n  const defaultAudioIndex = defaultAudio.index;\r\n  const defaultAudioGroupId = defaultAudio.groupId;\r\n\r\n  // Inject modal dialog HTML and CSS\r\n  const modalHtml = `\r\n    <div id=\"myModal\" class=\"modal\">\r\n      <div class=\"modal-content\">\r\n        <span class=\"close\">&times;</span>\r\n        <h2>Select Video and Audio Options</h2>\r\n        <label for=\"videoSelect\">Video Options:</label>\r\n        <select id=\"videoSelect\"></select>\r\n        <br>\r\n        <label for=\"audioSelect\">Audio Options:</label>\r\n        <select id=\"audioSelect\"></select>\r\n        <br>\r\n        <button id=\"startButton\">Download</button>\r\n      </div>\r\n    </div>\r\n  `;\r\n\r\n  const modalCss = `\r\n    .modal {\r\n      display: none;\r\n      position: fixed;\r\n      z-index: 1;\r\n      left: 0;\r\n      top: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      overflow: auto;\r\n      background-color: rgb(0,0,0);\r\n      background-color: rgba(0,0,0,0.4);\r\n    }\r\n    .modal-content {\r\n      background-color: #fefefe;\r\n      margin: 15% auto;\r\n      padding: 20px;\r\n      border: 1px solid #888;\r\n      width: 80%;\r\n      max-width: 500px;\r\n    }\r\n    .close {\r\n      color: #aaa;\r\n      float: right;\r\n      font-size: 28px;\r\n      font-weight: bold;\r\n    }\r\n    .close:hover,\r\n    .close:focus {\r\n      color: black;\r\n      text-decoration: none;\r\n      cursor: pointer;\r\n    }\r\n  `;\r\n\r\n  // Append CSS to the document head\r\n  const style = document.createElement('style');\r\n  style.innerHTML = modalCss;\r\n  document.head.appendChild(style);\r\n\r\n  // Append modal HTML to the document body\r\n  const modal = document.createElement('div');\r\n  modal.innerHTML = modalHtml;\r\n  document.body.appendChild(modal);\r\n\r\n  // Populate the video and audio select elements\r\n  const videoSelect = document.getElementById('videoSelect');\r\n  videoOptions.forEach(option => {\r\n    const opt = document.createElement('option');\r\n    opt.value = option.index;\r\n    opt.textContent = `Bandwidth: ${option.bandwidth}, Resolution: ${option.resolution.width}x${option.resolution.height}`;\r\n    videoSelect.appendChild(opt);\r\n  });\r\n\r\n  const audioSelect = document.getElementById('audioSelect');\r\n  audioOptions.forEach(option => {\r\n    const opt = document.createElement('option');\r\n    opt.value = JSON.stringify({ index: option.index, groupId: option.groupId });\r\n    opt.textContent = `URI: ${option.uri}`;\r\n    audioSelect.appendChild(opt);\r\n  });\r\n\r\n  // Set default selections\r\n  videoSelect.value = defaultVideoIndex;\r\n  audioSelect.value = JSON.stringify({ index: defaultAudioIndex, groupId: defaultAudioGroupId });\r\n\r\n  // Display the modal\r\n  const modalElement = document.getElementById('myModal');\r\n  modalElement.style.display = 'block';\r\n\r\n  // Close the modal when the user clicks on the close button\r\n  const closeButton = modalElement.querySelector('.close');\r\n  closeButton.onclick = () => modalElement.style.display = 'none';\r\n\r\n  // Start the download process when the user clicks the start button\r\n  const startButton = document.getElementById('startButton');\r\n  startButton.addEventListener('click', async () => {\r\n    const selectedVideoIndex = parseInt(videoSelect.value);\r\n    const { index: selectedAudioIndex, groupId: selectedAudioGroupId } = JSON.parse(audioSelect.value);\r\n\r\n    const videoVariant = masterPlaylist.playlists[selectedVideoIndex];\r\n    const audioVariant = Object.values(masterPlaylist.mediaGroups.AUDIO[selectedAudioGroupId])[selectedAudioIndex];\r\n\r\n    console.log(masterPlaylist.mediaGroups.AUDIO, selectedAudioGroupId, selectedAudioIndex);\r\n\r\n    console.log('variants', videoVariant, audioVariant);\r\n\r\n    const videoPlaylistUrl = new URL(videoVariant.uri, m3u8Url).toString();\r\n    const audioPlaylistUrl = new URL(audioVariant.uri, m3u8Url).toString();\r\n\r\n    // Fetch and parse the video and audio playlists concurrently\r\n    const [videoPlaylistContent, audioPlaylistContent] = await Promise.all([\r\n      fetch(videoPlaylistUrl).then(res => res.text()),\r\n      fetch(audioPlaylistUrl).then(res => res.text())\r\n    ]);\r\n\r\n    const videoParser = new Parser();\r\n    videoParser.push(videoPlaylistContent);\r\n    videoParser.end();\r\n    const videoPlaylist = videoParser.manifest;\r\n\r\n    const audioParser = new Parser();\r\n    audioParser.push(audioPlaylistContent);\r\n    audioParser.end();\r\n    const audioPlaylist = audioParser.manifest;\r\n\r\n    // Fetch the first segments of video and audio concurrently\r\n    const [video, audio] = await Promise.all([\r\n      fetch(new URL(videoPlaylist.segments[0].uri, videoPlaylistUrl)).then(res => res.arrayBuffer()).then(buf => new Uint8Array(buf)),\r\n      fetch(new URL(audioPlaylist.segments[0].uri, audioPlaylistUrl)).then(res => res.arrayBuffer()).then(buf => new Uint8Array(buf))\r\n    ]);\r\n\r\n    // Determine the segment file extensions\r\n    const videoExt = videoPlaylist.segments[0].uri.split('.').pop();\r\n    const audioExt = audioPlaylist.segments[0].uri.split('.').pop();\r\n    const videoFileName = `video.${videoExt}`;\r\n    const audioFileName = `audio.${audioExt}`;\r\n\r\n    // Write video and audio segments to ffmpeg FS\r\n    await ffmpeg.FS('writeFile', videoFileName, video);\r\n    await ffmpeg.FS('writeFile', audioFileName, audio);\r\n\r\n    // Merge video and audio segments\r\n    await ffmpeg.run('-i', videoFileName, '-i', audioFileName, '-c', 'copy', 'output.mp4');\r\n    const data = ffmpeg.FS('readFile', 'output.mp4');\r\n    window.ffmpeg.exit();\r\n\r\n    // Download the file from the buffer\r\n    const downloadLink = document.createElement('a');\r\n    downloadLink.href = window.URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));\r\n    downloadLink.download = `${document.title}.mp4`;\r\n    document.body.appendChild(downloadLink);\r\n    downloadLink.click();\r\n    document.body.removeChild(downloadLink);\r\n\r\n    // Close the modal\r\n    modalElement.style.display = 'none';\r\n  });\r\n})();\r\n","require('regenerator-runtime/runtime');\nconst createFFmpeg = require('./createFFmpeg');\nconst { fetchFile } = require('./node');\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile,\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","const { defaultArgs, baseOptions } = require('./config');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n  let customLogger = () => {};\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n  const log = (type, message) => {\n    customLogger({ type, message });\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n  const ts2sec = (ts) => {\n    const [h, m, s] = ts.split(':');\n    return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n  };\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({ duration: d, ratio });\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n        prog({ ratio, time: t });\n      } else if (message.startsWith('video:')) {\n        prog({ ratio: 1 });\n        duration = 0;\n      }\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n      running = false;\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    customLogger = _logger;\n  };\n\n  const setLogging = (_logging) => {\n    logging = _logging;\n  };\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n","module.exports = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    './ffmpeg',\n    /* Disable interaction mode */\n    '-nostdin',\n    /* Force to override output file */\n    '-y',\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {},\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {},\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: '',\n  },\n};\n","module.exports = (Core, args) => {\n  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n  args.forEach((s, idx) => {\n    const sz = Core.lengthBytesUTF8(s) + 1;\n    const buf = Core._malloc(sz);\n    Core.stringToUTF8(s, buf, sz);\n    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n","import defaultOptions from './defaultOptions';\nimport { getCreateFFmpegCore } from './getCreateFFmpegCore';\nimport { fetchFile } from './fetchFile';\n\nexport { defaultOptions, getCreateFFmpegCore, fetchFile };\n","import pkg from '../../package.json';\n\n/*\n * Default options for browser environment\n */\nconst corePath = typeof process !== 'undefined' && process.env.NODE_ENV === 'development'\n  ? new URL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js', import.meta.url).href\n  : `https://unpkg.com/@ffmpeg/core@${pkg.devDependencies['@ffmpeg/core'].substring(1)}/dist/ffmpeg-core.js`;\n\nexport default { corePath };\n","{\n  \"name\": \"@ffmpeg/ffmpeg\",\n  \"version\": \"0.11.6\",\n  \"description\": \"FFmpeg WebAssembly version\",\n  \"main\": \"src/index.js\",\n  \"types\": \"src/index.d.ts\",\n  \"directories\": {\n    \"example\": \"examples\"\n  },\n  \"scripts\": {\n    \"start\": \"node scripts/server.js\",\n    \"start:worker\": \"node scripts/worker-server.js\",\n    \"build\": \"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\n    \"build:worker\": \"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\n    \"prepublishOnly\": \"npm run build\",\n    \"lint\": \"eslint src\",\n    \"wait\": \"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\n    \"test\": \"npm-run-all -p -r start test:all\",\n    \"test:all\": \"npm-run-all wait test:browser:ffmpeg test:node:all\",\n    \"test:node\": \"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\n    \"test:node:all\": \"npm run test:node -- ./tests/*.test.js\",\n    \"test:browser\": \"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\n    \"test:browser:ffmpeg\": \"npm run test:browser -- -f ./tests/ffmpeg.test.html\"\n  },\n  \"browser\": {\n    \"./src/node/index.js\": \"./src/browser/index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"\n  },\n  \"keywords\": [\n    \"ffmpeg\",\n    \"WebAssembly\",\n    \"video\"\n  ],\n  \"author\": \"Jerome Wu <jeromewus@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"\n  },\n  \"engines\": {\n    \"node\": \">=12.16.1\"\n  },\n  \"homepage\": \"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\n  \"dependencies\": {\n    \"is-url\": \"^1.2.4\",\n    \"node-fetch\": \"^2.6.1\",\n    \"regenerator-runtime\": \"^0.13.7\",\n    \"resolve-url\": \"^0.2.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.12.3\",\n    \"@babel/preset-env\": \"^7.12.1\",\n    \"@ffmpeg/core\": \"^0.11.0\",\n    \"@types/emscripten\": \"^1.39.4\",\n    \"babel-eslint\": \"^10.1.0\",\n    \"babel-loader\": \"^8.1.0\",\n    \"chai\": \"^4.2.0\",\n    \"cors\": \"^2.8.5\",\n    \"eslint\": \"^7.12.1\",\n    \"eslint-config-airbnb-base\": \"^14.1.0\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"express\": \"^4.17.1\",\n    \"mocha\": \"^8.2.1\",\n    \"mocha-headless-chrome\": \"^2.0.3\",\n    \"npm-run-all\": \"^4.1.5\",\n    \"wait-on\": \"^5.3.0\",\n    \"webpack\": \"^5.3.2\",\n    \"webpack-cli\": \"^4.1.0\",\n    \"webpack-dev-middleware\": \"^4.0.0\"\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* eslint-disable no-undef */\nimport { log } from '../utils/log';\nimport {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n} from '../utils/errors';\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\nconst toBlobURL = async (url, mimeType) => {\n  log('info', `fetch ${url}`);\n  const buf = await (await fetch(url)).arrayBuffer();\n  log('info', `${url} file size = ${buf.byteLength} bytes`);\n  const blob = new Blob([buf], { type: mimeType });\n  const blobURL = URL.createObjectURL(blob);\n  log('info', `${url} blob URL = ${blobURL}`);\n  return blobURL;\n};\n\n// eslint-disable-next-line\nexport const getCreateFFmpegCore = async ({\n  corePath: _corePath,\n  workerPath: _workerPath,\n  wasmPath: _wasmPath,\n}) => {\n  // in Web Worker context\n  // eslint-disable-next-line\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    if (typeof _corePath !== 'string') {\n      throw Error('corePath should be a string!');\n    }\n    const coreRemotePath = new URL(_corePath, import.meta.url).href;\n    const corePath = await toBlobURL(\n      coreRemotePath,\n      'application/javascript',\n    );\n    const wasmPath = await toBlobURL(\n      _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n      'application/wasm',\n    );\n    const workerPath = await toBlobURL(\n      _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n      'application/javascript',\n    );\n    if (typeof createFFmpegCore === 'undefined') {\n      return new Promise((resolve) => {\n        globalThis.importScripts(corePath);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      });\n    }\n    log('info', 'ffmpeg-core.js script is loaded already');\n    return Promise.resolve({\n      createFFmpegCore,\n      corePath,\n      wasmPath,\n      workerPath,\n    });\n  }\n  if (typeof _corePath !== 'string') {\n    throw Error('corePath should be a string!');\n  }\n  const coreRemotePath = new URL(_corePath, import.meta.url).href;\n  const corePath = await toBlobURL(\n    coreRemotePath,\n    'application/javascript',\n  );\n  const wasmPath = await toBlobURL(\n    _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n    'application/wasm',\n  );\n  const workerPath = await toBlobURL(\n    _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n    'application/javascript',\n  );\n  if (typeof createFFmpegCore === 'undefined') {\n    return new Promise((resolve) => {\n      const script = document.createElement('script');\n      const eventHandler = () => {\n        script.removeEventListener('load', eventHandler);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      };\n      script.src = corePath;\n      script.type = 'text/javascript';\n      script.addEventListener('load', eventHandler);\n      document.getElementsByTagName('head')[0].appendChild(script);\n    });\n  }\n  log('info', 'ffmpeg-core.js script is loaded already');\n  return Promise.resolve({\n    createFFmpegCore,\n    corePath,\n    wasmPath,\n    workerPath,\n  });\n};\n","let logging = false;\nlet customLogger = () => {};\n\nconst setLogging = (_logging) => {\n  logging = _logging;\n};\n\nconst setCustomLogger = (logger) => {\n  customLogger = logger;\n};\n\nconst log = (type, message) => {\n  customLogger({ type, message });\n  if (logging) {\n    console.log(`[${type}] ${message}`);\n  }\n};\n\nmodule.exports = {\n  logging,\n  setLogging,\n  setCustomLogger,\n  log,\n};\n","const CREATE_FFMPEG_CORE_IS_NOT_DEFINED = (corePath) => (`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`);\n\nmodule.exports = {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n};\n","const readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\n// eslint-disable-next-line\nexport const fetchFile = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(new URL(_data, import.meta.url).href);\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n","/*! @name m3u8-parser @version 7.1.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            const split = event.attributes.RESOLUTION.split('x');\n            const resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor() {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition;\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!dateRange.endOnNext;\n\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };\n","/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };","function _extends() {\n  return (module.exports = _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _extends.apply(null, arguments);\n}\nmodule.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import window from 'global/window';\n\nvar atob = function atob(s) {\n  return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nexport default function decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$d3c1734dacb01657$var$currentQueue","$d154510a897fbed3$var$win","$8a0a73e6b73fd0c4$export$d622b2ad8d90c771","$8a0a73e6b73fd0c4$export$6100ba28696e12de","$998eb38f4d082829$export$aafa59e2e03f2942","$998eb38f4d082829$export$68d8715fc104d294","$parcel$global","globalThis","$15cc90f6d9fc0a3d$exports","$b6943471375d1c2a$var$runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","defineProperty","obj","key","desc","value","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","context","state","generator","create","protoGenerator","Generator","Context","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","methodName","TypeError","ContinueSentinel","record","tryCatch","type","info","done","resultName","next","nextLoc","sent","_sent","dispatchException","abrupt","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","_invoke","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rootEntry","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","$3b3cc656e4f26aad$exports","$616f69560e488f29$exports","$3b3cc656e4f26aad$require$defaultArgs","defaultArgs","baseOptions","log","logger","progress","corePath","$3b3cc656e4f26aad$require$baseOptions","$8e4d7ec1a6533651$exports","Core","args","argsPtr","_malloc","Uint32Array","BYTES_PER_ELEMENT","s","idx","sz","lengthBytesUTF8","buf","stringToUTF8","setValue","$a5bcf3ae1eb45eef$exports","JSON","parse","$d3c1734dacb01657$var$process","$d3c1734dacb01657$var$defaultSetTimout","$d3c1734dacb01657$var$defaultClearTimeout","$d3c1734dacb01657$var$runTimeout","fun","setTimeout","e","clearTimeout","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","concat","$d3c1734dacb01657$var$drainQueue","timeout","len","run","$d3c1734dacb01657$var$runClearTimeout","marker","$d3c1734dacb01657$var$Item","array","$d3c1734dacb01657$var$noop","nextTick","Array","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$d67d306687d6b921$var$corePath","devDependencies","substring","$051b5e070f34ce4a$exports","$051b5e070f34ce4a$var$logging","$051b5e070f34ce4a$var$customLogger","logging","setLogging","_logging","setCustomLogger","message","console","$43717573ac1f31b3$exports","CREATE_FFMPEG_CORE_IS_NOT_DEFINED","$88271dc11418d3fa$var$toBlobURL","url","mimeType","fetch","arrayBuffer","byteLength","blob","Blob","blobURL","URL","createObjectURL","$88271dc11418d3fa$export$e2417051082334b7","_corePath","workerPath","_workerPath","wasmPath","_wasmPath","WorkerGlobalScope","coreRemotePath","href","replace","createFFmpegCore","importScripts","script","document","createElement","eventHandler","removeEventListener","src","addEventListener","getElementsByTagName","appendChild","$4e2a226da6deaa1a$var$readFromBlobOrFile","fileReader","FileReader","onload","onerror","target","code","readAsArrayBuffer","$4e2a226da6deaa1a$export$d965bcb23f9d06c5","_data","data","Uint8Array","test","atob","split","map","c","charCodeAt","res","File","$3b3cc656e4f26aad$require$defaultOptions","$3b3cc656e4f26aad$require$version","$3b3cc656e4f26aad$var$NO_LOAD","createFFmpeg","_options","optLog","optProgress","options","ffmpeg","runResolve","runReject","running","customLogger","duration","frames","readFrames","ratio","detectCompletion","ts2sec","ts","h","m","parseFloat","parseProgress","prog","startsWith","d","match","fps","t","Math","min","f","time","parseMessage","load","$3b3cc656e4f26aad$require$getCreateFFmpegCore","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","mainName","setProgress","_progress","setLogger","_logger","isLoaded","_args","join","filter","exit","FS","ret","fetchFile","$240ec63f2cada8d3$export$2e2bcd8739ae039","Stream","_proto","listener","index","indexOf","splice","trigger","callbacks","_length","_i","dispose","pipe","destination","$fbb6a7bc8836e7ee$exports","$fbb6a7bc8836e7ee$var$_extends","assign","bind","n","r","$d154510a897fbed3$exports","b64","tmp","lens","$8a0a73e6b73fd0c4$var$getLens","validLen","placeHoldersLen","arr","$8a0a73e6b73fd0c4$var$Arr","curByte","$8a0a73e6b73fd0c4$var$revLookup","uint8","extraBytes","parts","len2","$8a0a73e6b73fd0c4$var$encodeChunk","start","end","output","$8a0a73e6b73fd0c4$var$lookup","num","$8a0a73e6b73fd0c4$var$code","$8a0a73e6b73fd0c4$var$i","$8a0a73e6b73fd0c4$var$len","buffer","offset","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","pow","rt","abs","Infinity","floor","LN2","$0934e0939605d48c$var$customInspectSymbol","$0934e0939605d48c$var$createBuffer","RangeError","$0934e0939605d48c$var$Buffer","encodingOrOffset","$0934e0939605d48c$var$allocUnsafe","$0934e0939605d48c$var$from","$0934e0939605d48c$var$fromString","string","encoding","isEncoding","$0934e0939605d48c$var$byteLength","actual","write","ArrayBuffer","isView","$0934e0939605d48c$var$fromArrayView","arrayView","$0934e0939605d48c$var$isInstance","copy","$0934e0939605d48c$var$fromArrayBuffer","byteOffset","$0934e0939605d48c$var$fromArrayLike","SharedArrayBuffer","valueOf","from","b","$0934e0939605d48c$var$fromObject","isBuffer","$0934e0939605d48c$var$checked","isArray","toPrimitive","$0934e0939605d48c$var$assertSize","size","mustMatch","loweredCase","$0934e0939605d48c$var$utf8ToBytes","$0934e0939605d48c$var$base64ToBytes","toLowerCase","$0934e0939605d48c$var$slowToString","$0934e0939605d48c$var$hexSlice","out","$0934e0939605d48c$var$hexSliceLookupTable","$0934e0939605d48c$var$utf8Slice","$0934e0939605d48c$var$asciiSlice","String","fromCharCode","$0934e0939605d48c$var$latin1Slice","$0934e0939605d48c$var$utf16leSlice","bytes","$0934e0939605d48c$var$swap","$0934e0939605d48c$var$bidirectionalIndexOf","$0934e0939605d48c$var$arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","$0934e0939605d48c$var$decodeCodePointsArray","codePoints","$0934e0939605d48c$var$checkOffset","ext","$0934e0939605d48c$var$checkInt","max","$0934e0939605d48c$var$wrtBigUInt64LE","$0934e0939605d48c$var$checkIntBI","lo","Number","BigInt","hi","$0934e0939605d48c$var$wrtBigUInt64BE","$0934e0939605d48c$var$checkIEEE754","$0934e0939605d48c$var$writeFloat","littleEndian","noAssert","$0934e0939605d48c$var$writeDouble","TYPED_ARRAY_SUPPORT","$0934e0939605d48c$var$typedArraySupport","proto","foo","get","poolSize","alloc","fill","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","x","y","list","pos","set","swap16","swap32","swap64","toString","toLocaleString","equals","inspect","str","trim","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","remaining","$0934e0939605d48c$var$hexWrite","strLen","parsed","parseInt","substr","$0934e0939605d48c$var$blitBuffer","$0934e0939605d48c$var$asciiToBytes","byteArray","$0934e0939605d48c$var$utf16leToBytes","units","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$0934e0939605d48c$var$defineBigIntMethod","$0934e0939605d48c$var$validateNumber","first","last","$0934e0939605d48c$var$boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$0934e0939605d48c$var$errors","$0934e0939605d48c$var$E","sym","getMessage","Base","stack","$0934e0939605d48c$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","$0934e0939605d48c$var$INVALID_BASE64_RE","leadSurrogate","$0934e0939605d48c$var$base64clean","dst","alphabet","table","i16","$0934e0939605d48c$var$BufferBigIntNotDefined","$d9ac9c5d7f472999$export$307ab5c52b11c33e","nextNewline","$d9ac9c5d7f472999$var$parseByterange","byterangeString","exec","$d9ac9c5d7f472999$var$parseAttributes","attributes","attr","attrs","RegExp","$d9ac9c5d7f472999$export$bc65cb5a6d9da573","customParsers","tagMappers","line","event","uri","newLines","reduce","acc","mapper","mappedLine","newLine","text","tagType","number","playlistType","allowed","URI","BYTERANGE","byterange","RESOLUTION","resolution","width","height","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","PRECISE","subkey","clientAttributePattern","isHexaDecimal","isDecimalFloating","addParser","expression","customType","dataParser","segment","addTagMapper","$d9ac9c5d7f472999$var$camelCase","toUpperCase","$d9ac9c5d7f472999$var$camelCaseKeys","$d9ac9c5d7f472999$var$setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","tag","hb","phb","minTargetDuration","minPartDuration","$d9ac9c5d7f472999$export$7acfa6ed01010e37","currentMap","lineStream","parseStream","lastProgramDateTime","uris","currentUri","hasParts","noop","defaultMediaGroups","currentTimeline","allowCache","discontinuityStarts","dateRanges","segments","lastByterangeEnd","lastPartByterangeEnd","dateRangeTags","preloadHints","timeline","preloadSegment","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","VALID_METHODS","KEYID","schemeIdUri","keyId","pssh","b64Text","decodedString","$39570e0c51fe4cb5$require$Buffer","iv","playlist","playlists","mediaGroups","media","TYPE","NAME","mediaGroupType","DEFAULT","autoselect","AUTOSELECT","LANGUAGE","language","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","getTime","reduceRight","programDateTime","targetduration","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","part","partIndex","renditionReports","canBlockReload","canSkipDateranges","hint","isPart","otherHint","report","required","partInf","partTarget","dateRange","endDate","startDate","plannedDuration","endOnNextYes","endOnNext","class","newDateInSeconds","id","attribute","stringify","dateRangeWithSameId","findIndex","dateRangeToFind","independentSegments","contentSteering","comment","custom","identifier","missing","chunk","m3u8Url","querySelector","getAttribute","response","masterPlaylistContent","masterParser","masterPlaylist","videoOptions","bandwidth","audioOptions","entries","AUDIO","flatMap","groupId","audios","audio","defaultVideoIndex","curr","defaultAudio","defaultAudioIndex","defaultAudioGroupId","modalHtml","modalCss","style","innerHTML","head","modal","body","videoSelect","getElementById","option","opt","textContent","audioSelect","modalElement","display","closeButton","onclick","startButton","selectedVideoIndex","selectedAudioIndex","selectedAudioGroupId","videoVariant","audioVariant","videoPlaylistUrl","audioPlaylistUrl","videoPlaylistContent","audioPlaylistContent","all","videoParser","videoPlaylist","audioParser","audioPlaylist","video","videoExt","audioExt","videoFileName","audioFileName","downloadLink","download","click","removeChild"],"version":3,"file":"index.js.map"}