{"mappings":"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","sources":["<anon>","src/index.js","node_modules/@ffmpeg/ffmpeg/src/index.js","node_modules/regenerator-runtime/runtime.js","node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js","node_modules/@ffmpeg/ffmpeg/src/config.js","node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js","node_modules/@ffmpeg/ffmpeg/src/browser/index.js","node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js","node_modules/@ffmpeg/ffmpeg/package.json","node_modules/process/browser.js","node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js","node_modules/@ffmpeg/ffmpeg/src/utils/log.js","node_modules/@ffmpeg/ffmpeg/src/utils/errors.js","node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js"],"sourcesContent":["(() => {\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $15cc90f6d9fc0a3d$exports = {};\nvar $b6943471375d1c2a$exports = {};\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var $b6943471375d1c2a$var$runtime = function(exports) {\n    \"use strict\";\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var defineProperty = Object.defineProperty || function(obj, key, desc) {\n        obj[key] = desc.value;\n    };\n    var undefined; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n        return obj[key];\n    }\n    try {\n        // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n        define({}, \"\");\n    } catch (err) {\n        define = function(obj, key, value) {\n            return obj[key] = value;\n        };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []);\n        // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n        defineProperty(generator, \"_invoke\", {\n            value: makeInvokeMethod(innerFn, self, context)\n        });\n        return generator;\n    }\n    exports.wrap = wrap;\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n        try {\n            return {\n                type: \"normal\",\n                arg: fn.call(obj, arg)\n            };\n        } catch (err) {\n            return {\n                type: \"throw\",\n                arg: err\n            };\n        }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function() {\n        return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    defineProperty(Gp, \"constructor\", {\n        value: GeneratorFunctionPrototype,\n        configurable: true\n    });\n    defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n        value: GeneratorFunction,\n        configurable: true\n    });\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n        [\n            \"next\",\n            \"throw\",\n            \"return\"\n        ].forEach(function(method) {\n            define(prototype, method, function(arg) {\n                return this._invoke(method, arg);\n            });\n        });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n        if (Object.setPrototypeOf) Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n            define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n        }\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n    };\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function(arg) {\n        return {\n            __await: arg\n        };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n        function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n            if (record.type === \"throw\") reject(record.arg);\n            else {\n                var result = record.arg;\n                var value = result.value;\n                if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) return PromiseImpl.resolve(value.__await).then(function(value) {\n                    invoke(\"next\", value, resolve, reject);\n                }, function(err) {\n                    invoke(\"throw\", err, resolve, reject);\n                });\n                return PromiseImpl.resolve(value).then(function(unwrapped) {\n                    // When a yielded Promise is resolved, its final value becomes\n                    // the .value of the Promise<{value,done}> result for the\n                    // current iteration.\n                    result.value = unwrapped;\n                    resolve(result);\n                }, function(error) {\n                    // If a rejected Promise was yielded, throw the rejection back\n                    // into the async generator function so it can be handled there.\n                    return invoke(\"throw\", error, resolve, reject);\n                });\n            }\n        }\n        var previousPromise;\n        function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n                return new PromiseImpl(function(resolve, reject) {\n                    invoke(method, arg, resolve, reject);\n                });\n            }\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n        // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n        defineProperty(this, \"_invoke\", {\n            value: enqueue\n        });\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n        return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n        if (PromiseImpl === void 0) PromiseImpl = Promise;\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n         : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n        });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n            if (state === GenStateExecuting) throw new Error(\"Generator is already running\");\n            if (state === GenStateCompleted) {\n                if (method === \"throw\") throw arg;\n                // Be forgiving, per 25.3.3.3.3 of the spec:\n                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n                return doneResult();\n            }\n            context.method = method;\n            context.arg = arg;\n            while(true){\n                var delegate = context.delegate;\n                if (delegate) {\n                    var delegateResult = maybeInvokeDelegate(delegate, context);\n                    if (delegateResult) {\n                        if (delegateResult === ContinueSentinel) continue;\n                        return delegateResult;\n                    }\n                }\n                if (context.method === \"next\") // Setting context._sent for legacy support of Babel's\n                // function.sent implementation.\n                context.sent = context._sent = context.arg;\n                else if (context.method === \"throw\") {\n                    if (state === GenStateSuspendedStart) {\n                        state = GenStateCompleted;\n                        throw context.arg;\n                    }\n                    context.dispatchException(context.arg);\n                } else if (context.method === \"return\") context.abrupt(\"return\", context.arg);\n                state = GenStateExecuting;\n                var record = tryCatch(innerFn, self, context);\n                if (record.type === \"normal\") {\n                    // If an exception is thrown from innerFn, we leave state ===\n                    // GenStateExecuting and loop back for another invocation.\n                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                    if (record.arg === ContinueSentinel) continue;\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                } else if (record.type === \"throw\") {\n                    state = GenStateCompleted;\n                    // Dispatch the exception by looping back around to the\n                    // context.dispatchException(context.arg) call above.\n                    context.method = \"throw\";\n                    context.arg = record.arg;\n                }\n            }\n        };\n    }\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n        var methodName = context.method;\n        var method = delegate.iterator[methodName];\n        if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method, or a missing .next mehtod, always terminate the\n            // yield* loop.\n            context.delegate = null;\n            // Note: [\"return\"] must be used for ES3 parsing compatibility.\n            if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n                // If the delegate iterator has a return method, give it a\n                // chance to clean up.\n                context.method = \"return\";\n                context.arg = undefined;\n                maybeInvokeDelegate(delegate, context);\n                if (context.method === \"throw\") // If maybeInvokeDelegate(context) changed context.method from\n                // \"return\" to \"throw\", let that override the TypeError below.\n                return ContinueSentinel;\n            }\n            if (methodName !== \"return\") {\n                context.method = \"throw\";\n                context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n            }\n            return ContinueSentinel;\n        }\n        var record = tryCatch(method, delegate.iterator, context.arg);\n        if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        var info = record.arg;\n        if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value;\n            // Resume execution at the desired location (see delegateYield).\n            context.next = delegate.nextLoc;\n            // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n            if (context.method !== \"return\") {\n                context.method = \"next\";\n                context.arg = undefined;\n            }\n        } else // Re-yield the result returned by the delegate method.\n        return info;\n        // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n        context.delegate = null;\n        return ContinueSentinel;\n    }\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function() {\n        return this;\n    });\n    define(Gp, \"toString\", function() {\n        return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n        var entry = {\n            tryLoc: locs[0]\n        };\n        if (1 in locs) entry.catchLoc = locs[1];\n        if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n        }\n        this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n    }\n    function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [\n            {\n                tryLoc: \"root\"\n            }\n        ];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n    }\n    exports.keys = function(val) {\n        var object = Object(val);\n        var keys = [];\n        for(var key in object)keys.push(key);\n        keys.reverse();\n        // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n        return function next() {\n            while(keys.length){\n                var key = keys.pop();\n                if (key in object) {\n                    next.value = key;\n                    next.done = false;\n                    return next;\n                }\n            }\n            // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n            next.done = true;\n            return next;\n        };\n    };\n    function values(iterable) {\n        if (iterable) {\n            var iteratorMethod = iterable[iteratorSymbol];\n            if (iteratorMethod) return iteratorMethod.call(iterable);\n            if (typeof iterable.next === \"function\") return iterable;\n            if (!isNaN(iterable.length)) {\n                var i = -1, next = function next() {\n                    while(++i < iterable.length)if (hasOwn.call(iterable, i)) {\n                        next.value = iterable[i];\n                        next.done = false;\n                        return next;\n                    }\n                    next.value = undefined;\n                    next.done = true;\n                    return next;\n                };\n                return next.next = next;\n            }\n        }\n        // Return an iterator with no values.\n        return {\n            next: doneResult\n        };\n    }\n    exports.values = values;\n    function doneResult() {\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    Context.prototype = {\n        constructor: Context,\n        reset: function(skipTempReset) {\n            this.prev = 0;\n            this.next = 0;\n            // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n            if (!skipTempReset) {\n                for(var name in this)// Not sure about the optimal order of these conditions:\n                if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) this[name] = undefined;\n            }\n        },\n        stop: function() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n            if (rootRecord.type === \"throw\") throw rootRecord.arg;\n            return this.rval;\n        },\n        dispatchException: function(exception) {\n            if (this.done) throw exception;\n            var context = this;\n            function handle(loc, caught) {\n                record.type = \"throw\";\n                record.arg = exception;\n                context.next = loc;\n                if (caught) {\n                    // If the dispatched exception was caught by a catch block,\n                    // then let that catch block handle the exception normally.\n                    context.method = \"next\";\n                    context.arg = undefined;\n                }\n                return !!caught;\n            }\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                var record = entry.completion;\n                if (entry.tryLoc === \"root\") // Exception thrown outside of any try block that could handle\n                // it, so set the completion value of the entire function to\n                // throw the exception.\n                return handle(\"end\");\n                if (entry.tryLoc <= this.prev) {\n                    var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                    var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                    if (hasCatch && hasFinally) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                        else if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else if (hasCatch) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                    } else if (hasFinally) {\n                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else throw new Error(\"try statement without catch or finally\");\n                }\n            }\n        },\n        abrupt: function(type, arg) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                    var finallyEntry = entry;\n                    break;\n                }\n            }\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) // Ignore the finally entry if control is not jumping to a\n            // location outside the try/catch block.\n            finallyEntry = null;\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n            if (finallyEntry) {\n                this.method = \"next\";\n                this.next = finallyEntry.finallyLoc;\n                return ContinueSentinel;\n            }\n            return this.complete(record);\n        },\n        complete: function(record, afterLoc) {\n            if (record.type === \"throw\") throw record.arg;\n            if (record.type === \"break\" || record.type === \"continue\") this.next = record.arg;\n            else if (record.type === \"return\") {\n                this.rval = this.arg = record.arg;\n                this.method = \"return\";\n                this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) this.next = afterLoc;\n            return ContinueSentinel;\n        },\n        finish: function(finallyLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.finallyLoc === finallyLoc) {\n                    this.complete(entry.completion, entry.afterLoc);\n                    resetTryEntry(entry);\n                    return ContinueSentinel;\n                }\n            }\n        },\n        \"catch\": function(tryLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc === tryLoc) {\n                    var record = entry.completion;\n                    if (record.type === \"throw\") {\n                        var thrown = record.arg;\n                        resetTryEntry(entry);\n                    }\n                    return thrown;\n                }\n            }\n            // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n            throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function(iterable, resultName, nextLoc) {\n            this.delegate = {\n                iterator: values(iterable),\n                resultName: resultName,\n                nextLoc: nextLoc\n            };\n            if (this.method === \"next\") // Deliberately forget the last sent value so that we don't\n            // accidentally pass it on to the delegate.\n            this.arg = undefined;\n            return ContinueSentinel;\n        }\n    };\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n}(// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n(0, $b6943471375d1c2a$exports));\ntry {\n    regeneratorRuntime = $b6943471375d1c2a$var$runtime;\n} catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") globalThis.regeneratorRuntime = $b6943471375d1c2a$var$runtime;\n    else Function(\"r\", \"regeneratorRuntime = r\")($b6943471375d1c2a$var$runtime);\n}\n\n\nvar $3b3cc656e4f26aad$exports = {};\nvar $616f69560e488f29$exports = {};\n$616f69560e488f29$exports = {\n    defaultArgs: [\n        /* args[0] is always the binary path */ \"./ffmpeg\",\n        /* Disable interaction mode */ \"-nostdin\",\n        /* Force to override output file */ \"-y\"\n    ],\n    baseOptions: {\n        /* Flag to turn on/off log messages in console */ log: false,\n        /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */ logger: ()=>{},\n        /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */ progress: ()=>{},\n        /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */ corePath: \"\"\n    }\n};\n\n\nvar $3b3cc656e4f26aad$require$defaultArgs = $616f69560e488f29$exports.defaultArgs;\nvar $3b3cc656e4f26aad$require$baseOptions = $616f69560e488f29$exports.baseOptions;\nvar $8e4d7ec1a6533651$exports = {};\n$8e4d7ec1a6533651$exports = (Core, args)=>{\n    const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n    args.forEach((s, idx)=>{\n        const sz = Core.lengthBytesUTF8(s) + 1;\n        const buf = Core._malloc(sz);\n        Core.stringToUTF8(s, buf, sz);\n        Core.setValue(argsPtr + Uint32Array.BYTES_PER_ELEMENT * idx, buf, \"i32\");\n    });\n    return [\n        args.length,\n        argsPtr\n    ];\n};\n\n\nvar $a5bcf3ae1eb45eef$exports = {};\n$a5bcf3ae1eb45eef$exports = JSON.parse('{\"name\":\"@ffmpeg/ffmpeg\",\"version\":\"0.11.6\",\"description\":\"FFmpeg WebAssembly version\",\"main\":\"src/index.js\",\"types\":\"src/index.d.ts\",\"directories\":{\"example\":\"examples\"},\"scripts\":{\"start\":\"node scripts/server.js\",\"start:worker\":\"node scripts/worker-server.js\",\"build\":\"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\"build:worker\":\"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\"prepublishOnly\":\"npm run build\",\"lint\":\"eslint src\",\"wait\":\"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\"test\":\"npm-run-all -p -r start test:all\",\"test:all\":\"npm-run-all wait test:browser:ffmpeg test:node:all\",\"test:node\":\"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\"test:node:all\":\"npm run test:node -- ./tests/*.test.js\",\"test:browser\":\"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\"test:browser:ffmpeg\":\"npm run test:browser -- -f ./tests/ffmpeg.test.html\"},\"browser\":{\"./src/node/index.js\":\"./src/browser/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"},\"keywords\":[\"ffmpeg\",\"WebAssembly\",\"video\"],\"author\":\"Jerome Wu <jeromewus@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"},\"engines\":{\"node\":\">=12.16.1\"},\"homepage\":\"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\"dependencies\":{\"is-url\":\"^1.2.4\",\"node-fetch\":\"^2.6.1\",\"regenerator-runtime\":\"^0.13.7\",\"resolve-url\":\"^0.2.1\"},\"devDependencies\":{\"@babel/core\":\"^7.12.3\",\"@babel/preset-env\":\"^7.12.1\",\"@ffmpeg/core\":\"^0.11.0\",\"@types/emscripten\":\"^1.39.4\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.1.0\",\"chai\":\"^4.2.0\",\"cors\":\"^2.8.5\",\"eslint\":\"^7.12.1\",\"eslint-config-airbnb-base\":\"^14.1.0\",\"eslint-plugin-import\":\"^2.22.1\",\"express\":\"^4.17.1\",\"mocha\":\"^8.2.1\",\"mocha-headless-chrome\":\"^2.0.3\",\"npm-run-all\":\"^4.1.5\",\"wait-on\":\"^5.3.0\",\"webpack\":\"^5.3.2\",\"webpack-cli\":\"^4.1.0\",\"webpack-dev-middleware\":\"^4.0.0\"}}');\n\n\nvar $d3c1734dacb01657$exports = {};\n// shim for using process in browser\nvar $d3c1734dacb01657$var$process = $d3c1734dacb01657$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d3c1734dacb01657$var$cachedSetTimeout;\nvar $d3c1734dacb01657$var$cachedClearTimeout;\nfunction $d3c1734dacb01657$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $d3c1734dacb01657$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        else $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        else $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    }\n})();\nfunction $d3c1734dacb01657$var$runTimeout(fun) {\n    if ($d3c1734dacb01657$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedSetTimeout === $d3c1734dacb01657$var$defaultSetTimout || !$d3c1734dacb01657$var$cachedSetTimeout) && setTimeout) {\n        $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d3c1734dacb01657$var$runClearTimeout(marker) {\n    if ($d3c1734dacb01657$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedClearTimeout === $d3c1734dacb01657$var$defaultClearTimeout || !$d3c1734dacb01657$var$cachedClearTimeout) && clearTimeout) {\n        $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d3c1734dacb01657$var$queue = [];\nvar $d3c1734dacb01657$var$draining = false;\nvar $d3c1734dacb01657$var$currentQueue;\nvar $d3c1734dacb01657$var$queueIndex = -1;\nfunction $d3c1734dacb01657$var$cleanUpNextTick() {\n    if (!$d3c1734dacb01657$var$draining || !$d3c1734dacb01657$var$currentQueue) return;\n    $d3c1734dacb01657$var$draining = false;\n    if ($d3c1734dacb01657$var$currentQueue.length) $d3c1734dacb01657$var$queue = $d3c1734dacb01657$var$currentQueue.concat($d3c1734dacb01657$var$queue);\n    else $d3c1734dacb01657$var$queueIndex = -1;\n    if ($d3c1734dacb01657$var$queue.length) $d3c1734dacb01657$var$drainQueue();\n}\nfunction $d3c1734dacb01657$var$drainQueue() {\n    if ($d3c1734dacb01657$var$draining) return;\n    var timeout = $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$cleanUpNextTick);\n    $d3c1734dacb01657$var$draining = true;\n    var len = $d3c1734dacb01657$var$queue.length;\n    while(len){\n        $d3c1734dacb01657$var$currentQueue = $d3c1734dacb01657$var$queue;\n        $d3c1734dacb01657$var$queue = [];\n        while(++$d3c1734dacb01657$var$queueIndex < len)if ($d3c1734dacb01657$var$currentQueue) $d3c1734dacb01657$var$currentQueue[$d3c1734dacb01657$var$queueIndex].run();\n        $d3c1734dacb01657$var$queueIndex = -1;\n        len = $d3c1734dacb01657$var$queue.length;\n    }\n    $d3c1734dacb01657$var$currentQueue = null;\n    $d3c1734dacb01657$var$draining = false;\n    $d3c1734dacb01657$var$runClearTimeout(timeout);\n}\n$d3c1734dacb01657$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d3c1734dacb01657$var$queue.push(new $d3c1734dacb01657$var$Item(fun, args));\n    if ($d3c1734dacb01657$var$queue.length === 1 && !$d3c1734dacb01657$var$draining) $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d3c1734dacb01657$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d3c1734dacb01657$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d3c1734dacb01657$var$process.title = \"browser\";\n$d3c1734dacb01657$var$process.browser = true;\n$d3c1734dacb01657$var$process.env = {};\n$d3c1734dacb01657$var$process.argv = [];\n$d3c1734dacb01657$var$process.version = \"\"; // empty string to avoid regexp issues\n$d3c1734dacb01657$var$process.versions = {};\nfunction $d3c1734dacb01657$var$noop() {}\n$d3c1734dacb01657$var$process.on = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.addListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.once = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.off = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeAllListeners = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.emit = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependOnceListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.listeners = function(name) {\n    return [];\n};\n$d3c1734dacb01657$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$d3c1734dacb01657$var$process.cwd = function() {\n    return \"/\";\n};\n$d3c1734dacb01657$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$d3c1734dacb01657$var$process.umask = function() {\n    return 0;\n};\n\n\n/*\n * Default options for browser environment\n */ const $d67d306687d6b921$var$corePath = (typeof $d3c1734dacb01657$exports, `https://unpkg.com/@ffmpeg/core@${(0, (/*@__PURE__*/$parcel$interopDefault($a5bcf3ae1eb45eef$exports))).devDependencies[\"@ffmpeg/core\"].substring(1)}/dist/ffmpeg-core.js`);\nvar $d67d306687d6b921$export$2e2bcd8739ae039 = {\n    corePath: $d67d306687d6b921$var$corePath\n};\n\n\n/* eslint-disable no-undef */ var $051b5e070f34ce4a$exports = {};\nlet $051b5e070f34ce4a$var$logging = false;\nlet $051b5e070f34ce4a$var$customLogger = ()=>{};\nconst $051b5e070f34ce4a$var$setLogging = (_logging)=>{\n    $051b5e070f34ce4a$var$logging = _logging;\n};\nconst $051b5e070f34ce4a$var$setCustomLogger = (logger)=>{\n    $051b5e070f34ce4a$var$customLogger = logger;\n};\nconst $051b5e070f34ce4a$var$log = (type, message)=>{\n    $051b5e070f34ce4a$var$customLogger({\n        type: type,\n        message: message\n    });\n    if ($051b5e070f34ce4a$var$logging) console.log(`[${type}] ${message}`);\n};\n$051b5e070f34ce4a$exports = {\n    logging: $051b5e070f34ce4a$var$logging,\n    setLogging: $051b5e070f34ce4a$var$setLogging,\n    setCustomLogger: $051b5e070f34ce4a$var$setCustomLogger,\n    log: $051b5e070f34ce4a$var$log\n};\n\n\nvar $43717573ac1f31b3$exports = {};\nconst $43717573ac1f31b3$var$CREATE_FFMPEG_CORE_IS_NOT_DEFINED = (corePath)=>`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`;\n$43717573ac1f31b3$exports = {\n    CREATE_FFMPEG_CORE_IS_NOT_DEFINED: $43717573ac1f31b3$var$CREATE_FFMPEG_CORE_IS_NOT_DEFINED\n};\n\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */ const $88271dc11418d3fa$var$toBlobURL = async (url, mimeType)=>{\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `fetch ${url}`);\n    const buf = await (await fetch(url)).arrayBuffer();\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `${url} file size = ${buf.byteLength} bytes`);\n    const blob = new Blob([\n        buf\n    ], {\n        type: mimeType\n    });\n    const blobURL = URL.createObjectURL(blob);\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", `${url} blob URL = ${blobURL}`);\n    return blobURL;\n};\nconst $88271dc11418d3fa$export$e2417051082334b7 = async ({ corePath: _corePath, workerPath: _workerPath, wasmPath: _wasmPath })=>{\n    // in Web Worker context\n    // eslint-disable-next-line\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n        if (typeof _corePath !== \"string\") throw Error(\"corePath should be a string!\");\n        const coreRemotePath = new URL(_corePath, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js\").href;\n        const corePath = await $88271dc11418d3fa$var$toBlobURL(coreRemotePath, \"application/javascript\");\n        const wasmPath = await $88271dc11418d3fa$var$toBlobURL(_wasmPath !== undefined ? _wasmPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"), \"application/wasm\");\n        const workerPath = await $88271dc11418d3fa$var$toBlobURL(_workerPath !== undefined ? _workerPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"), \"application/javascript\");\n        if (typeof createFFmpegCore === \"undefined\") return new Promise((resolve)=>{\n            globalThis.importScripts(corePath);\n            if (typeof createFFmpegCore === \"undefined\") throw Error((0, $43717573ac1f31b3$exports.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath));\n            (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script loaded\");\n            resolve({\n                createFFmpegCore: createFFmpegCore,\n                corePath: corePath,\n                wasmPath: wasmPath,\n                workerPath: workerPath\n            });\n        });\n        (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script is loaded already\");\n        return Promise.resolve({\n            createFFmpegCore: createFFmpegCore,\n            corePath: corePath,\n            wasmPath: wasmPath,\n            workerPath: workerPath\n        });\n    }\n    if (typeof _corePath !== \"string\") throw Error(\"corePath should be a string!\");\n    const coreRemotePath = new URL(_corePath, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js\").href;\n    const corePath = await $88271dc11418d3fa$var$toBlobURL(coreRemotePath, \"application/javascript\");\n    const wasmPath = await $88271dc11418d3fa$var$toBlobURL(_wasmPath !== undefined ? _wasmPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"), \"application/wasm\");\n    const workerPath = await $88271dc11418d3fa$var$toBlobURL(_workerPath !== undefined ? _workerPath : coreRemotePath.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"), \"application/javascript\");\n    if (typeof createFFmpegCore === \"undefined\") return new Promise((resolve)=>{\n        const script = document.createElement(\"script\");\n        const eventHandler = ()=>{\n            script.removeEventListener(\"load\", eventHandler);\n            if (typeof createFFmpegCore === \"undefined\") throw Error((0, $43717573ac1f31b3$exports.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath));\n            (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script loaded\");\n            resolve({\n                createFFmpegCore: createFFmpegCore,\n                corePath: corePath,\n                wasmPath: wasmPath,\n                workerPath: workerPath\n            });\n        };\n        script.src = corePath;\n        script.type = \"text/javascript\";\n        script.addEventListener(\"load\", eventHandler);\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n    (0, $051b5e070f34ce4a$exports.log)(\"info\", \"ffmpeg-core.js script is loaded already\");\n    return Promise.resolve({\n        createFFmpegCore: createFFmpegCore,\n        corePath: corePath,\n        wasmPath: wasmPath,\n        workerPath: workerPath\n    });\n};\n\n\nconst $4e2a226da6deaa1a$var$readFromBlobOrFile = (blob)=>new Promise((resolve, reject)=>{\n        const fileReader = new FileReader();\n        fileReader.onload = ()=>{\n            resolve(fileReader.result);\n        };\n        fileReader.onerror = ({ target: { error: { code: code } } })=>{\n            reject(Error(`File could not be read! Code=${code}`));\n        };\n        fileReader.readAsArrayBuffer(blob);\n    });\nconst $4e2a226da6deaa1a$export$d965bcb23f9d06c5 = async (_data)=>{\n    let data = _data;\n    if (typeof _data === \"undefined\") return new Uint8Array();\n    if (typeof _data === \"string\") {\n        /* From base64 format */ if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) data = atob(_data.split(\",\")[1]).split(\"\").map((c)=>c.charCodeAt(0));\n        else {\n            const res = await fetch(new URL(_data, \"file:///node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js\").href);\n            data = await res.arrayBuffer();\n        }\n    } else if (_data instanceof File || _data instanceof Blob) data = await $4e2a226da6deaa1a$var$readFromBlobOrFile(_data);\n    return new Uint8Array(data);\n};\n\n\n\n\nvar $3b3cc656e4f26aad$require$defaultOptions = $d67d306687d6b921$export$2e2bcd8739ae039;\nvar $3b3cc656e4f26aad$require$getCreateFFmpegCore = $88271dc11418d3fa$export$e2417051082334b7;\n\nvar $3b3cc656e4f26aad$require$version = $a5bcf3ae1eb45eef$exports.version;\nconst $3b3cc656e4f26aad$var$NO_LOAD = Error(\"ffmpeg.wasm is not ready, make sure you have completed load().\");\n$3b3cc656e4f26aad$exports = (_options = {})=>{\n    const { log: optLog, logger: logger, progress: optProgress, ...options } = {\n        ...$3b3cc656e4f26aad$require$baseOptions,\n        ...$3b3cc656e4f26aad$require$defaultOptions,\n        ..._options\n    };\n    let Core = null;\n    let ffmpeg = null;\n    let runResolve = null;\n    let runReject = null;\n    let running = false;\n    let customLogger = ()=>{};\n    let logging = optLog;\n    let progress = optProgress;\n    let duration = 0;\n    let frames = 0;\n    let readFrames = false;\n    let ratio = 0;\n    const detectCompletion = (message)=>{\n        if (message === \"FFMPEG_END\" && runResolve !== null) {\n            runResolve();\n            runResolve = null;\n            runReject = null;\n            running = false;\n        }\n    };\n    const log = (type, message)=>{\n        customLogger({\n            type: type,\n            message: message\n        });\n        if (logging) console.log(`[${type}] ${message}`);\n    };\n    const ts2sec = (ts)=>{\n        const [h, m, s] = ts.split(\":\");\n        return parseFloat(h) * 3600 + parseFloat(m) * 60 + parseFloat(s);\n    };\n    const parseProgress = (message, prog)=>{\n        if (typeof message === \"string\") {\n            if (message.startsWith(\"  Duration\")) {\n                const ts = message.split(\", \")[0].split(\": \")[1];\n                const d = ts2sec(ts);\n                prog({\n                    duration: d,\n                    ratio: ratio\n                });\n                if (duration === 0 || duration > d) {\n                    duration = d;\n                    readFrames = true;\n                }\n            } else if (readFrames && message.startsWith(\"    Stream\")) {\n                const match = message.match(/([\\d.]+) fps/);\n                if (match) {\n                    const fps = parseFloat(match[1]);\n                    frames = duration * fps;\n                } else frames = 0;\n                readFrames = false;\n            } else if (message.startsWith(\"frame\") || message.startsWith(\"size\")) {\n                const ts = message.split(\"time=\")[1].split(\" \")[0];\n                const t = ts2sec(ts);\n                const match = message.match(/frame=\\s*(\\d+)/);\n                if (frames && match) {\n                    const f = parseFloat(match[1]);\n                    ratio = Math.min(f / frames, 1);\n                } else ratio = t / duration;\n                prog({\n                    ratio: ratio,\n                    time: t\n                });\n            } else if (message.startsWith(\"video:\")) {\n                prog({\n                    ratio: 1\n                });\n                duration = 0;\n            }\n        }\n    };\n    const parseMessage = ({ type: type, message: message })=>{\n        log(type, message);\n        parseProgress(message, progress);\n        detectCompletion(message);\n    };\n    /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */ const load = async ()=>{\n        log(\"info\", \"load ffmpeg-core\");\n        if (Core === null) {\n            log(\"info\", \"loading ffmpeg-core\");\n            /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */ const { createFFmpegCore: createFFmpegCore, corePath: corePath, workerPath: workerPath, wasmPath: wasmPath } = await $3b3cc656e4f26aad$require$getCreateFFmpegCore(options);\n            Core = await createFFmpegCore({\n                /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */ mainScriptUrlOrBlob: corePath,\n                printErr: (message)=>parseMessage({\n                        type: \"fferr\",\n                        message: message\n                    }),\n                print: (message)=>parseMessage({\n                        type: \"ffout\",\n                        message: message\n                    }),\n                /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */ locateFile: (path, prefix)=>{\n                    if (typeof window !== \"undefined\" || typeof WorkerGlobalScope !== \"undefined\") {\n                        if (typeof wasmPath !== \"undefined\" && path.endsWith(\"ffmpeg-core.wasm\")) return wasmPath;\n                        if (typeof workerPath !== \"undefined\" && path.endsWith(\"ffmpeg-core.worker.js\")) return workerPath;\n                    }\n                    return prefix + path;\n                }\n            });\n            ffmpeg = Core.cwrap(options.mainName || \"proxy_main\", \"number\", [\n                \"number\",\n                \"number\"\n            ]);\n            log(\"info\", \"ffmpeg-core loaded\");\n        } else throw Error(\"ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.\");\n    };\n    /*\n   * Determine whether the Core is loaded.\n   */ const isLoaded = ()=>Core !== null;\n    /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */ const run = (..._args)=>{\n        log(\"info\", `run ffmpeg command: ${_args.join(\" \")}`);\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else if (running) throw Error(\"ffmpeg.wasm can only run one command at a time\");\n        else {\n            running = true;\n            return new Promise((resolve, reject)=>{\n                const args = [\n                    ...$3b3cc656e4f26aad$require$defaultArgs,\n                    ..._args\n                ].filter((s)=>s.length !== 0);\n                runResolve = resolve;\n                runReject = reject;\n                ffmpeg(...$8e4d7ec1a6533651$exports(Core, args));\n            });\n        }\n    };\n    /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */ const FS = (method, ...args)=>{\n        log(\"info\", `run FS.${method} ${args.map((arg)=>typeof arg === \"string\" ? arg : `<${arg.length} bytes binary file>`).join(\" \")}`);\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else {\n            let ret = null;\n            try {\n                ret = Core.FS[method](...args);\n            } catch (e) {\n                if (method === \"readdir\") throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n                else if (method === \"readFile\") throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n                else throw Error(\"Oops, something went wrong in FS operation.\");\n            }\n            return ret;\n        }\n    };\n    /**\n   * forcibly terminate the ffmpeg program.\n   */ const exit = ()=>{\n        if (Core === null) throw $3b3cc656e4f26aad$var$NO_LOAD;\n        else {\n            // if there's any pending runs, reject them\n            if (runReject) runReject(\"ffmpeg has exited\");\n            running = false;\n            try {\n                Core.exit(1);\n            } catch (err) {\n                log(err.message);\n                if (runReject) runReject(err);\n            } finally{\n                Core = null;\n                ffmpeg = null;\n                runResolve = null;\n                runReject = null;\n            }\n        }\n    };\n    const setProgress = (_progress)=>{\n        progress = _progress;\n    };\n    const setLogger = (_logger)=>{\n        customLogger = _logger;\n    };\n    const setLogging = (_logging)=>{\n        logging = _logging;\n    };\n    log(\"info\", `use ffmpeg.wasm v${$3b3cc656e4f26aad$require$version}`);\n    return {\n        setProgress: setProgress,\n        setLogger: setLogger,\n        setLogging: setLogging,\n        load: load,\n        isLoaded: isLoaded,\n        run: run,\n        exit: exit,\n        FS: FS\n    };\n};\n\n\n\nvar $15cc90f6d9fc0a3d$require$fetchFile = $4e2a226da6deaa1a$export$d965bcb23f9d06c5;\n$15cc90f6d9fc0a3d$exports = {\n    createFFmpeg: /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */ $3b3cc656e4f26aad$exports,\n    fetchFile: $15cc90f6d9fc0a3d$require$fetchFile\n};\n\n\n// assign ffmpeg to window.ffmpeg if it doesn't already exist\nwindow.ffmpeg ??= (0, $15cc90f6d9fc0a3d$exports.createFFmpeg)({\n    mainName: \"main\",\n    log: true,\n    corePath: \"https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js\"\n});\n(async ()=>{\n    // load ffmpeg if it isn't already loaded\n    window.ffmpeg.isLoaded() || await window.ffmpeg.load();\n    // get the base url for the video and audio files\n    const baseUrl = document.querySelector(\".thumbnail\")?.getAttribute(\"href\");\n    const videoPromise = (async ()=>{\n        for (const resolution of [\n            1080,\n            720,\n            480,\n            360,\n            270,\n            240,\n            220\n        ]){\n            const response = await fetch(`${baseUrl}/DASH_${resolution}.mp4`);\n            if (response.status === 200) {\n                await ffmpeg.FS(\"writeFile\", \"video.mp4\", new Uint8Array(await response.arrayBuffer()));\n                return true;\n            }\n        }\n        return false;\n    })();\n    const audioPromise = (async ()=>{\n        for (const bitrate of [\n            \"\",\n            \"_128\",\n            \"_64\"\n        ]){\n            const response = await fetch(`${baseUrl}/DASH_AUDIO${bitrate}.mp4`);\n            if (response.status === 200) {\n                await ffmpeg.FS(\"writeFile\", \"audio.mp4\", new Uint8Array(await response.arrayBuffer()));\n                return true;\n            }\n        }\n        return false;\n    })();\n    // fetch then write video and audio files simultaneously\n    await Promise.allSettled([\n        videoPromise,\n        audioPromise\n    ]);\n    // either merge the video and audio, or just rename the video file if there is no audio\n    if (await audioPromise) await ffmpeg.run(\"-i\", \"video.mp4\", \"-i\", \"audio.mp4\", \"-c:v\", \"copy\", \"-c:a\", \"aac\", \"-map\", \"0:v:0\", \"-map\", \"1:a:0\", \"output.mp4\");\n    else await ffmpeg.run(\"-i\", \"video.mp4\", \"-c:v\", \"copy\", \"-c:a\", \"copy\", \"-map\", \"0:v:0\", \"output.mp4\");\n    // read the file into a buffer and exit ffmpeg\n    const data = ffmpeg.FS(\"readFile\", \"output.mp4\");\n    window.ffmpeg.exit();\n    // download the file from the buffer\n    const downloadLink = document.createElement(\"a\");\n    downloadLink.href = window.URL.createObjectURL(new Blob([\n        data.buffer\n    ], {\n        type: \"video/mp4\"\n    }));\n    downloadLink.download = `${document.title}.mp4`;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n})();\n\n})();\n//# sourceMappingURL=index.js.map\n","import { createFFmpeg } from '@ffmpeg/ffmpeg';\n\n// assign ffmpeg to window.ffmpeg if it doesn't already exist\nwindow.ffmpeg ??= createFFmpeg({\n  mainName: 'main',\n  log: true,\n  corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',\n});\n\n(async () => {\n  // load ffmpeg if it isn't already loaded\n  window.ffmpeg.isLoaded() || await window.ffmpeg.load();\n\n  // get the base url for the video and audio files\n  const baseUrl = document.querySelector('.thumbnail')?.getAttribute('href');\n\n  const videoPromise = (async () => {\n    for (const resolution of [1080, 720, 480, 360, 270, 240, 220]) {\n      const response = await fetch(`${baseUrl}/DASH_${resolution}.mp4`);\n      if (response.status === 200) {\n        await ffmpeg.FS('writeFile', 'video.mp4', new Uint8Array(await response.arrayBuffer()));\n        return true;\n      }\n    }\n    return false;\n  })();\n\n  const audioPromise = (async () => {\n    for (const bitrate of ['', '_128', '_64']) {\n      const response = await fetch(`${baseUrl}/DASH_AUDIO${bitrate}.mp4`);\n      if (response.status === 200) {\n        await ffmpeg.FS('writeFile', 'audio.mp4', new Uint8Array(await response.arrayBuffer()));\n        return true;\n      }\n    }\n    return false;\n  })();\n\n\n  // fetch then write video and audio files simultaneously\n  await Promise.allSettled([\n    videoPromise,\n    audioPromise\n  ]);\n\n  // either merge the video and audio, or just rename the video file if there is no audio\n  if (await audioPromise) {\n    await ffmpeg.run('-i', 'video.mp4', '-i', 'audio.mp4', '-c:v', 'copy', '-c:a', 'aac', '-map', '0:v:0', '-map', '1:a:0', 'output.mp4');\n  } else {\n    await ffmpeg.run('-i', 'video.mp4', '-c:v', 'copy', '-c:a', 'copy', '-map', '0:v:0', 'output.mp4');\n  }\n\n  // read the file into a buffer and exit ffmpeg\n  const data = ffmpeg.FS('readFile', 'output.mp4');\n  window.ffmpeg.exit();\n\n  // download the file from the buffer\n  const downloadLink = document.createElement('a');\n  downloadLink.href = window.URL.createObjectURL(new Blob([data.buffer], {\n    type: 'video/mp4'\n  }));\n  downloadLink.download = `${document.title}.mp4`;\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  document.body.removeChild(downloadLink);\n})();","require('regenerator-runtime/runtime');\nconst createFFmpeg = require('./createFFmpeg');\nconst { fetchFile } = require('./node');\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile,\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","const { defaultArgs, baseOptions } = require('./config');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n  let customLogger = () => {};\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n  const log = (type, message) => {\n    customLogger({ type, message });\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n  const ts2sec = (ts) => {\n    const [h, m, s] = ts.split(':');\n    return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n  };\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({ duration: d, ratio });\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n        prog({ ratio, time: t });\n      } else if (message.startsWith('video:')) {\n        prog({ ratio: 1 });\n        duration = 0;\n      }\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n      running = false;\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    customLogger = _logger;\n  };\n\n  const setLogging = (_logging) => {\n    logging = _logging;\n  };\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n","module.exports = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    './ffmpeg',\n    /* Disable interaction mode */\n    '-nostdin',\n    /* Force to override output file */\n    '-y',\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {},\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {},\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: '',\n  },\n};\n","module.exports = (Core, args) => {\n  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n  args.forEach((s, idx) => {\n    const sz = Core.lengthBytesUTF8(s) + 1;\n    const buf = Core._malloc(sz);\n    Core.stringToUTF8(s, buf, sz);\n    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n","import defaultOptions from './defaultOptions';\nimport { getCreateFFmpegCore } from './getCreateFFmpegCore';\nimport { fetchFile } from './fetchFile';\n\nexport { defaultOptions, getCreateFFmpegCore, fetchFile };\n","import pkg from '../../package.json';\n\n/*\n * Default options for browser environment\n */\nconst corePath = typeof process !== 'undefined' && process.env.NODE_ENV === 'development'\n  ? new URL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js', import.meta.url).href\n  : `https://unpkg.com/@ffmpeg/core@${pkg.devDependencies['@ffmpeg/core'].substring(1)}/dist/ffmpeg-core.js`;\n\nexport default { corePath };\n","{\n  \"name\": \"@ffmpeg/ffmpeg\",\n  \"version\": \"0.11.6\",\n  \"description\": \"FFmpeg WebAssembly version\",\n  \"main\": \"src/index.js\",\n  \"types\": \"src/index.d.ts\",\n  \"directories\": {\n    \"example\": \"examples\"\n  },\n  \"scripts\": {\n    \"start\": \"node scripts/server.js\",\n    \"start:worker\": \"node scripts/worker-server.js\",\n    \"build\": \"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\n    \"build:worker\": \"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\n    \"prepublishOnly\": \"npm run build\",\n    \"lint\": \"eslint src\",\n    \"wait\": \"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\n    \"test\": \"npm-run-all -p -r start test:all\",\n    \"test:all\": \"npm-run-all wait test:browser:ffmpeg test:node:all\",\n    \"test:node\": \"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\n    \"test:node:all\": \"npm run test:node -- ./tests/*.test.js\",\n    \"test:browser\": \"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\n    \"test:browser:ffmpeg\": \"npm run test:browser -- -f ./tests/ffmpeg.test.html\"\n  },\n  \"browser\": {\n    \"./src/node/index.js\": \"./src/browser/index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"\n  },\n  \"keywords\": [\n    \"ffmpeg\",\n    \"WebAssembly\",\n    \"video\"\n  ],\n  \"author\": \"Jerome Wu <jeromewus@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"\n  },\n  \"engines\": {\n    \"node\": \">=12.16.1\"\n  },\n  \"homepage\": \"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\",\n  \"dependencies\": {\n    \"is-url\": \"^1.2.4\",\n    \"node-fetch\": \"^2.6.1\",\n    \"regenerator-runtime\": \"^0.13.7\",\n    \"resolve-url\": \"^0.2.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.12.3\",\n    \"@babel/preset-env\": \"^7.12.1\",\n    \"@ffmpeg/core\": \"^0.11.0\",\n    \"@types/emscripten\": \"^1.39.4\",\n    \"babel-eslint\": \"^10.1.0\",\n    \"babel-loader\": \"^8.1.0\",\n    \"chai\": \"^4.2.0\",\n    \"cors\": \"^2.8.5\",\n    \"eslint\": \"^7.12.1\",\n    \"eslint-config-airbnb-base\": \"^14.1.0\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"express\": \"^4.17.1\",\n    \"mocha\": \"^8.2.1\",\n    \"mocha-headless-chrome\": \"^2.0.3\",\n    \"npm-run-all\": \"^4.1.5\",\n    \"wait-on\": \"^5.3.0\",\n    \"webpack\": \"^5.3.2\",\n    \"webpack-cli\": \"^4.1.0\",\n    \"webpack-dev-middleware\": \"^4.0.0\"\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* eslint-disable no-undef */\nimport { log } from '../utils/log';\nimport {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n} from '../utils/errors';\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\nconst toBlobURL = async (url, mimeType) => {\n  log('info', `fetch ${url}`);\n  const buf = await (await fetch(url)).arrayBuffer();\n  log('info', `${url} file size = ${buf.byteLength} bytes`);\n  const blob = new Blob([buf], { type: mimeType });\n  const blobURL = URL.createObjectURL(blob);\n  log('info', `${url} blob URL = ${blobURL}`);\n  return blobURL;\n};\n\n// eslint-disable-next-line\nexport const getCreateFFmpegCore = async ({\n  corePath: _corePath,\n  workerPath: _workerPath,\n  wasmPath: _wasmPath,\n}) => {\n  // in Web Worker context\n  // eslint-disable-next-line\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    if (typeof _corePath !== 'string') {\n      throw Error('corePath should be a string!');\n    }\n    const coreRemotePath = new URL(_corePath, import.meta.url).href;\n    const corePath = await toBlobURL(\n      coreRemotePath,\n      'application/javascript',\n    );\n    const wasmPath = await toBlobURL(\n      _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n      'application/wasm',\n    );\n    const workerPath = await toBlobURL(\n      _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n      'application/javascript',\n    );\n    if (typeof createFFmpegCore === 'undefined') {\n      return new Promise((resolve) => {\n        globalThis.importScripts(corePath);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      });\n    }\n    log('info', 'ffmpeg-core.js script is loaded already');\n    return Promise.resolve({\n      createFFmpegCore,\n      corePath,\n      wasmPath,\n      workerPath,\n    });\n  }\n  if (typeof _corePath !== 'string') {\n    throw Error('corePath should be a string!');\n  }\n  const coreRemotePath = new URL(_corePath, import.meta.url).href;\n  const corePath = await toBlobURL(\n    coreRemotePath,\n    'application/javascript',\n  );\n  const wasmPath = await toBlobURL(\n    _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n    'application/wasm',\n  );\n  const workerPath = await toBlobURL(\n    _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n    'application/javascript',\n  );\n  if (typeof createFFmpegCore === 'undefined') {\n    return new Promise((resolve) => {\n      const script = document.createElement('script');\n      const eventHandler = () => {\n        script.removeEventListener('load', eventHandler);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      };\n      script.src = corePath;\n      script.type = 'text/javascript';\n      script.addEventListener('load', eventHandler);\n      document.getElementsByTagName('head')[0].appendChild(script);\n    });\n  }\n  log('info', 'ffmpeg-core.js script is loaded already');\n  return Promise.resolve({\n    createFFmpegCore,\n    corePath,\n    wasmPath,\n    workerPath,\n  });\n};\n","let logging = false;\nlet customLogger = () => {};\n\nconst setLogging = (_logging) => {\n  logging = _logging;\n};\n\nconst setCustomLogger = (logger) => {\n  customLogger = logger;\n};\n\nconst log = (type, message) => {\n  customLogger({ type, message });\n  if (logging) {\n    console.log(`[${type}] ${message}`);\n  }\n};\n\nmodule.exports = {\n  logging,\n  setLogging,\n  setCustomLogger,\n  log,\n};\n","const CREATE_FFMPEG_CORE_IS_NOT_DEFINED = (corePath) => (`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`);\n\nmodule.exports = {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n};\n","const readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\n// eslint-disable-next-line\nexport const fetchFile = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(new URL(_data, import.meta.url).href);\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n"],"names":["a","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$d3c1734dacb01657$var$currentQueue","$15cc90f6d9fc0a3d$exports","$b6943471375d1c2a$var$runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","defineProperty","obj","key","desc","value","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","context","state","generator","create","protoGenerator","Generator","Context","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","methodName","TypeError","ContinueSentinel","record","tryCatch","type","info","done","resultName","next","nextLoc","sent","_sent","dispatchException","abrupt","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","_invoke","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rootEntry","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","globalThis","Function","$3b3cc656e4f26aad$exports","$616f69560e488f29$exports","$3b3cc656e4f26aad$require$defaultArgs","defaultArgs","baseOptions","log","logger","progress","corePath","$3b3cc656e4f26aad$require$baseOptions","$8e4d7ec1a6533651$exports","Core","args","argsPtr","_malloc","Uint32Array","BYTES_PER_ELEMENT","s","idx","sz","lengthBytesUTF8","buf","stringToUTF8","setValue","$a5bcf3ae1eb45eef$exports","JSON","parse","$d3c1734dacb01657$var$process","$d3c1734dacb01657$var$defaultSetTimout","$d3c1734dacb01657$var$defaultClearTimeout","$d3c1734dacb01657$var$runTimeout","fun","setTimeout","e","clearTimeout","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","concat","$d3c1734dacb01657$var$drainQueue","timeout","len","run","$d3c1734dacb01657$var$runClearTimeout","marker","$d3c1734dacb01657$var$Item","array","$d3c1734dacb01657$var$noop","nextTick","Array","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$d67d306687d6b921$var$corePath","__esModule","default","devDependencies","substring","$051b5e070f34ce4a$exports","$051b5e070f34ce4a$var$logging","$051b5e070f34ce4a$var$customLogger","logging","setLogging","_logging","setCustomLogger","message","console","$43717573ac1f31b3$exports","CREATE_FFMPEG_CORE_IS_NOT_DEFINED","$88271dc11418d3fa$var$toBlobURL","url","mimeType","fetch","arrayBuffer","byteLength","blob","Blob","blobURL","URL","createObjectURL","$88271dc11418d3fa$export$e2417051082334b7","_corePath","workerPath","_workerPath","wasmPath","_wasmPath","WorkerGlobalScope","coreRemotePath","href","replace","createFFmpegCore","importScripts","script","document","createElement","eventHandler","removeEventListener","src","addEventListener","getElementsByTagName","appendChild","$4e2a226da6deaa1a$var$readFromBlobOrFile","fileReader","FileReader","onload","onerror","target","code","readAsArrayBuffer","$4e2a226da6deaa1a$export$d965bcb23f9d06c5","_data","data","Uint8Array","test","atob","split","map","c","charCodeAt","res","File","$3b3cc656e4f26aad$require$defaultOptions","$3b3cc656e4f26aad$require$version","$3b3cc656e4f26aad$var$NO_LOAD","createFFmpeg","_options","optLog","optProgress","options","ffmpeg","runResolve","runReject","running","customLogger","duration","frames","readFrames","ratio","detectCompletion","ts2sec","ts","h","m","parseFloat","parseProgress","prog","startsWith","d","match","fps","t","f","Math","min","time","parseMessage","load","$3b3cc656e4f26aad$require$getCreateFFmpegCore","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","mainName","setProgress","_progress","setLogger","_logger","isLoaded","_args","join","filter","exit","FS","ret","fetchFile","baseUrl","querySelector","getAttribute","videoPromise","resolution","response","status","audioPromise","bitrate","allSettled","downloadLink","buffer","download","body","click","removeChild"],"version":3,"file":"index.js.map"}